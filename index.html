<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>背水一战</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="背水一战">
<meta property="og:url" content="https://github.com/MExuanHe/MExuanHe.github.io/index.html">
<meta property="og:site_name" content="背水一战">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/MExuanHe.github.io/atom.xml" title="背水一战" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/MExuanHe.github.io/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/MExuanHe.github.io/" id="logo">背水一战</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/MExuanHe.github.io/">Home</a>
        
          <a class="main-nav-link" href="/MExuanHe.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/MExuanHe.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/MExuanHe/MExuanHe.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS降低APP崩溃率" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/24/iOS%E9%99%8D%E4%BD%8EAPP%E5%B4%A9%E6%BA%83%E7%8E%87/" class="article-date">
  <time datetime="2020-05-24T14:53:08.000Z" itemprop="datePublished">2020-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/24/iOS%E9%99%8D%E4%BD%8EAPP%E5%B4%A9%E6%BA%83%E7%8E%87/">iOS降低APP崩溃率</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作为一个资深的技术团队，app的性能是我们技术团队首要的任务，其中最主要的一项就是app的崩溃率。<br>目前虽然不能把系统所有的crash都处理掉，不过一些常见的高频次发生的crash，系统都会处理。目前主要可以处理掉的crash类型有一下几种：</p>
<ul>
<li>unrecognized selector crash</li>
<li>KVO crash</li>
<li>NSNotification crash</li>
<li>NSTimer crash</li>
<li>Container crash（数组越界，插nil等）</li>
<li>NSString crash （字符串操作的crash）</li>
<li>UI not on Main Thread Crash (非主线程刷UI(机制待改善))<h5 id="下面会一一讲解如何解决这些carsh"><a href="#下面会一一讲解如何解决这些carsh" class="headerlink" title="下面会一一讲解如何解决这些carsh"></a>下面会一一讲解如何解决这些carsh</h5></li>
</ul>
<h2 id="unrecognized-selector-crash"><a href="#unrecognized-selector-crash" class="headerlink" title="unrecognized selector crash"></a>unrecognized selector crash</h2><p>unrecognized selector类型的crash是经常发生的carsh，我们要解决这个carsh就必须先了解它产生的具体原因和流程。</p>
<p>什么时候会报unrecognized selector的异常？</p>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX</p>
<p>在找不到方法时，查找方法将会进入方法Forward流程,系统给了三次补救的机会，所以我们要解决这个问题，在这三次均可以解决这个问题<br><img src="/MExuanHe.github.io/fancybox/images/rootsearch.png" alt="图片"><br>由上图可见，在一个函数找不到时，runtime提供了三种方式去补救：</p>
<p>1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数<br>2、调用forwardingTargetForSelector让别的对象去执行这个函数<br>3、调用forwardInvocation（函数执行器)灵活的将目标函数以其他形式执行。</p>
<p>如果都不中，调用doesNotRecognizeSelector抛出异常。既然可以补救,我们可以用消息转发机制来做，我们选择了第二步forwardingTargetForSelector来做，原因如下：</p>
<p>1、resolveInstanceMethod 需要在类的本身上动态添加它本身不存在的方法，这些方法对于该类本身来说冗余的</p>
<p>2、forwardInvocation可以通过NSInvocation的形式将消息转发给多个对象，但是其开销较大，需要创建新的NSInvocation对象，并且forwardInvocation的函数经常被使用者调用，来做多层消息转发选择机制，不适合多次重写</p>
<p>3、forwardingTargetForSelector可以将消息转发给一个对象，开销较小，并且被重写的概率较低，适合重写<br>选择了forwardingTargetForSelector之后，可以将NSObject的该方法重写</p>
<p>做以下几步的处理：</p>
<p>1、动态创建一个桩类</p>
<p>2、动态为桩类添加对应的Selector，用一个通用的返回0的函数来实现该SEL的IMP</p>
<p>3、将消息直接转发到这个桩类对象上。<br>流程图如下：<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3ef056e30b35.png" alt="图片2"><br>注意如果对象的类本事如果重写了forwardInvocation方法的话，就不应该对forwardingTargetForSelector进行重写了，否则会影响到该类型的对象原本的消息转发流程。</p>
<p>通过重写NSObject的forwardingTargetForSelector方法，我们就可以将无法识别的方法进行拦截并且将消息转发到安全的桩类对象中，从而可以使app继续正常运行。</p>
<h2 id="KVO-crash"><a href="#KVO-crash" class="headerlink" title="KVO crash"></a>KVO crash</h2><p>如果观察者和keypath的数量一多，很容易理不清楚被观察对象整个KVO关系，导致被观察者在dealloc的时候，还残存着一些关系没有被注销。 同时还会导致KVO注册观察者与移除观察者不匹配的情况发生。<br>那么如何来管理混乱的KVO关系呢。可以让被观察对象持有一个KVO的delegate，所有和KVO相关的操作均通过delegate来进行管理，delegate通过建立一张map来维护KVO整个关系<br>这样做的好处有两个：</p>
<p>1、如果出现KVO重复添加观察者或重复移除观察者（KVO注册观察者与移除观察者不匹配）的情况，delegate可以直接阻止这些非正常的操作。</p>
<p>2、被观察对象dealloc之前，可以通过delegate自动将与自己有关的KVO关系都注销掉，避免了KVO的被观察者dealloc时仍然注册着KVO导致的crash。<br>被swizzle的方法分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer </span><br><span class="line">			forKeyPath:(NSString *)keyPath</span><br><span class="line">			 	options:(NSKeyValueObservingOptions)options </span><br><span class="line">			 	context:(nullable void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</span><br></pre></td></tr></table></figure>

<p>关于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer </span><br><span class="line">			forKeyPath:(NSString *)keyPath</span><br><span class="line">			 	options:(NSKeyValueObservingOptions)options </span><br><span class="line">			 	context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<p><strong>方法改造流程如下图：</strong><br><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d3ef057740bea?w=883&h=658&f=png&s=31134" alt="图片3.png"><br>通过上面的流程，将observerd对象的所有kvo相关的observer信息全部转移到KVOdelegate上，并且避免了相同kvoinfo被重复添加多次的可能性。<br>关于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObserver:(NSObject *)observer</span><br><span class="line">            forKeyPath:(NSString *)keyPath</span><br><span class="line">               context:(void *)context</span><br></pre></td></tr></table></figure>
<p>方法改造流程如下图：<br><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d3ef058373d96?w=675&h=750&f=png&s=32478" alt="图片 4.png"><br>移除一个keypath的Observer时，当delegate的kvoInfoMap中找不到key为该keypath的时候，说明此时delegate并没有持有对应keypath的observer，即说明移除了一个不匹配的观察者，此时如果再继续操作会导致app崩溃，所以应该及时中断流程，然后统计异常信息。</p>
<p>当keypath对应的KVOInfo列表（infoArray）为空的时候，说明此时delegate已经不再持有任何和keypath相关的observer了。这时应该调用原有removeObserver的方法将delegate对应的观察者移除。<br>注意到在检查遍历infoArray的时侯，除了要删除对应的info信息，还多了一步检查info.observer == nil的过程，是因为如果observer为nil，那么此时如果keypath对应的值变化的话，也会因为找不到observer而崩溃，所以需要做这一步来阻止该种情况的发生。</p>
<h6 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary&lt;NSString *,id&gt; *)change</span><br><span class="line">                       context:(void *)context</span><br></pre></td></tr></table></figure>
<p>delegate对于observeValueForKeyPath方法的修改最主要的地法规，在于将对应的响应方法转移给真正的KVO Observer，通过keyInfoMap找到keypath对应的KVOInfo里面预先存储好的observer，然后调用observer原本的响应方法</p>
<p>同时在遍历InfoArray的时候，发现info.observerw == nil的时候，需要及时将其清除掉，避免KVO的观察者observer被释放后value变化导致的crash</p>
<p>最后，针对 KVO的被观察者dealloc时仍然注册着KVO导致的crash 的情况</p>
<p>可以将NSObject的dealloc swizzle， 在object dealloc的时候自动将其对应的kvodelegate所有和kvo相关的数据清空，然后将kvodelegate也置空。避免出现KVO的被观察者dealloc时仍然注册着KVO而产生的crash</p>
<h2 id="NSNotification-crash"><a href="#NSNotification-crash" class="headerlink" title="NSNotification crash"></a>NSNotification crash</h2><p>当一个对象添加了notification之后，如果dealloc的时候，仍然持有notification，就会出现NSNotification类型的crash。</p>
<p>利用method swizzling hook NSObject的dealloc函数，再对象真正dealloc之前先调用一下[[NSNotificationCenter defaultCenter] removeObserver:self] 即可。</p>
<p>注意到并不是所有的对象都需要做以上的操作，如果一个对象从来没有被NSNotificationCenter 添加为observer的话，在其dealloc之前调用removeObserver完全是多此一举。 所以我们hook了NSNotificationCenter的addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject 函数，在其添加observer的时候，对observer动态添加标记flag。这样在observer dealloc的时候，就可以通过flag标记来判断其是否有必要调用removeObserver函数了。</p>
<h2 id="NSTimer-crash"><a href="#NSTimer-crash" class="headerlink" title="NSTimer crash"></a>NSTimer crash</h2><p>NSTimer存在以下问题:<br>•    Target是强引用，内存泄漏<br>•    在宿主不存在的时候，清理NSTimer</p>
<p>解决方法: Hook NSTimer中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats方法</span><br></pre></td></tr></table></figure>

<p>1、当repeats为NO时，走原始方法<br>2、当repeats为YES时，新建一个对象，声明一个target属性为weak类型，指向参数的target,当中间对象的target为空时，清理NSTimer</p>
<h2 id="Container-crash（数组越界，插nil等）"><a href="#Container-crash（数组越界，插nil等）" class="headerlink" title="Container crash（数组越界，插nil等）"></a>Container crash（数组越界，插nil等）</h2><p>Container 类型的crash 指的是容器类的crash</p>
<p><strong>常见的有:</strong></p>
<ul>
<li>NSArray</li>
<li>NSMutableArray</li>
<li>NSDictionary</li>
<li>NSMutableDictionary</li>
<li>NSCache</li>
</ul>
<p>一些常见的越界，插入nil，等错误操作均会导致此类crash发生</p>
<p>Container crash 类型的防护方案也比较简单,针对于NSArray／NSMutableArray／NSDictionary／NSMutableDictionary／NSCache的一些常用的会导致崩溃的API进行method swizzling，然后在swizzle的新方法中加入一些条件限制和判断，从而让这些API变的安全，这里就不展开来具体描述了。</p>
<h2 id="NSString-crash-（字符串操作的crash）"><a href="#NSString-crash-（字符串操作的crash）" class="headerlink" title="NSString crash （字符串操作的crash）"></a>NSString crash （字符串操作的crash）</h2><p>NSString／NSMutableString 类型的crash的产生原因和防护方案与Container crash很相像，这里也不展开来描述了。</p>
<h2 id="UI-not-on-Main-Thread-Crash-非主线程刷UI"><a href="#UI-not-on-Main-Thread-Crash-非主线程刷UI" class="headerlink" title="UI not on Main Thread Crash (非主线程刷UI)"></a>UI not on Main Thread Crash (非主线程刷UI)</h2><p>在非主线程刷UI将会导致app运行crash，有必要对其进行处理。 目前初步的处理方案是swizzle UIView类的以下三个方法：</p>
<ul>
<li>(void)setNeedsLayout;</li>
<li>(void)setNeedsDisplay;</li>
<li>(void)setNeedsDisplayInRect:(CGRect)rect;</li>
</ul>
<p>在这三个方法调用的时候判断一下当前的线程，如果不是主线程的话，直接利用<br>dispatch_async(dispatch_get_main_queue(), ^{<br>//调用原本方法<br>});</p>
<p>来将对应的刷UI的操作转移到主线程上，同时统计错误信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/24/iOS%E9%99%8D%E4%BD%8EAPP%E5%B4%A9%E6%BA%83%E7%8E%87/" data-id="ckamlrppl0002xj76enr1a73j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS无侵入的埋点方案如何实现？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/24/iOS%E6%97%A0%E4%BE%B5%E5%85%A5%E7%9A%84%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/" class="article-date">
  <time datetime="2020-05-24T14:49:57.000Z" itemprop="datePublished">2020-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/24/iOS%E6%97%A0%E4%BE%B5%E5%85%A5%E7%9A%84%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/">iOS无侵入的埋点方案如何实现？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开发过程中，埋点可以解决两大类问题：一是了解用户使用 App 的行为，二是降低分析线上问题的难度。目前，iOS 开发中常见的埋点方式，主要包括：</p>
<ul>
<li>代码埋点</li>
<li>可视化埋点</li>
<li>无埋点</li>
</ul>
<h3 id="代码埋点"><a href="#代码埋点" class="headerlink" title="代码埋点"></a>代码埋点</h3><p>代码埋点主要就是通过手写代码的方式来埋点，能很精确的在需要埋点的代码处加上埋点的代码，可以很方便地记录当前环境的变量值，方便调试，并跟踪埋点内容，但存在开发工作量大，并且埋点代码到处都是，后期难以维护等问题。  </p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>显而易见，你会在后期维护的时候写的怀疑人生</li>
<li>复用性差，几乎不能移植给其他项目</li>
<li>工作量大，而且会越写越多</li>
<li>统计代码上线之后，如果出现问题，只能后续版本迭代</li>
<li>如果统计项目名字改变了，原来老的APP版本依旧会统计老的页面名字</li>
</ol>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>如果非要写一个其他统计无法做到的优点的话，那就是可自定义程度高吧，统计代码想写到那里写到那里（其实这些也可以在后面的方案实现，只是实现上稍微麻烦一点罢了）</li>
<li>最容易想到的方案（前期费时少，使用起来费手不费思路）</li>
</ol>
<h3 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h3><p>就是将埋点增加和修改的工作可视化了，提升了增加和维护埋点的体验。</p>
<h4 id="该方案的具体步骤就是："><a href="#该方案的具体步骤就是：" class="headerlink" title="该方案的具体步骤就是："></a>该方案的具体步骤就是：</h4><ol>
<li>从后台获取需要统计的地方</li>
<li>hook住需要统计的类的load方法来Method Swizzing要统计的方法</li>
<li>上传统计到的事件给后台分析</li>
</ol>
<p>用<code>UIViewController</code>、<code>UIControl</code>为例子，讲解一下该方案的思路。</p>
<p>UIViewController PV统计,页面的统计较为简单，利用Method Swizzing hook 系统的viewDidLoad， 直接通过页面名称即可锁定页面的展示代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+(void)load &#123; </span><br><span class="line">     <span class="keyword">static</span> dispatch_once_t onceToken; </span><br><span class="line">     dispatch_once(&amp;onceToken, ^&#123; </span><br><span class="line">     <span class="type">SEL</span> originalDidLoadSelector = @selector(viewDidLoad); </span><br><span class="line">     <span class="type">SEL</span> swizzingDidLoadSelector = @selector(analytic_viewDidLoad); </span><br><span class="line">     [<span class="type">MethodSwizzingTool</span> swizzingForClass:[<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>] <span class="title">originalSel</span>:<span class="title">originalDidLoadSelector</span> <span class="title">swizzingSel</span>:<span class="title">swizzingDidLoadSelector</span>]; </span></span><br><span class="line"><span class="class">&#125;); </span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"> -(<span class="title">void</span>)<span class="title">analytic_viewDidLoad</span> </span>&#123;</span><br><span class="line">    [<span class="keyword">self</span>  analytic_viewDidLoad]; </span><br><span class="line">    <span class="comment">//用当前类的类名作为统计页面的标识符  </span></span><br><span class="line">    <span class="type">NSString</span> * identifier = [<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@"</span>, [<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>]];</span></span><br><span class="line"><span class="class">     //通过当前类名获取<span class="title">PAGEPV</span>表内的对应的页面的<span class="title">pageid</span>和<span class="title">pagename</span>  </span></span><br><span class="line"><span class="class">     <span class="title">NSDictionary</span> * <span class="title">dic</span> = [[[<span class="title">AnalyticTool</span> <span class="title">shareInstance</span>].<span class="title">data</span> <span class="title">objectForKey</span>:@"<span class="title">PAGE</span>"] <span class="title">objectForKey</span>:<span class="title">identifier</span>]; </span></span><br><span class="line"><span class="class">     <span class="title">if</span> (<span class="title">dic</span>) </span>&#123; </span><br><span class="line">     <span class="type">NSString</span> * pageid = dic[@<span class="string">"screenData"</span>][@<span class="string">"pageid"</span>]; </span><br><span class="line">     <span class="type">NSString</span> * pagename = dic[@<span class="string">"screenData"</span>][@<span class="string">"pagename"</span>]; </span><br><span class="line">     [<span class="type">AnalyticTool</span> upLoadScreenName:pagename withScreenID:pageid]; </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="type">UIControl</span> 点击统计,主要通过hook sendAction:to:forEvent: 来实现, 其唯一标识符我们用 targetname/selector/tag来标记，具体代码如下：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line">+(void)load </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">static</span> dispatch_once_t onceToken; </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123; </span><br><span class="line">    <span class="type">SEL</span> originalSelector = @selector(sendAction:to:forEvent:); </span><br><span class="line">    <span class="type">SEL</span> swizzingSelector = @selector(analytic_sendAction:to:forEvent:); </span><br><span class="line">    [<span class="type">MethodSwizzingTool</span> swizzingForClass:[<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>] <span class="title">originalSel</span>:<span class="title">originalSelector</span> <span class="title">swizzingSel</span>:<span class="title">swizzingSelector</span>]; </span></span><br><span class="line"><span class="class">    &#125;); </span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-(<span class="title">void</span>)<span class="title">analytic_sendAction</span>:(<span class="title">SEL</span>)<span class="title">action</span> <span class="title">to</span>:(<span class="title">id</span>)<span class="title">target</span> <span class="title">forEvent</span>:(<span class="title">UIEvent</span> *)<span class="title">event</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">     [<span class="keyword">self</span> analytic_sendAction:action to:target forEvent:event];</span><br><span class="line">     <span class="type">NSString</span> * identifier = [<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@/%@/%ld"</span>, [target <span class="class"><span class="keyword">class</span>], </span></span><br><span class="line"><span class="class">     <span class="title">NSStringFromSelector</span>(<span class="title">action</span>),<span class="title">self</span>.<span class="title">tag</span>]; <span class="title">NSDictionary</span> * <span class="title">dic</span> = [[[<span class="title">AnalyticTool</span> <span class="title">shareInstance</span>].<span class="title">data</span> <span class="title">objectForKey</span>:@"<span class="title">ACTION</span>"] <span class="title">objectForKey</span>:<span class="title">identifier</span>]; </span></span><br><span class="line"><span class="class">     <span class="title">if</span> (<span class="title">dic</span>) </span>&#123;</span><br><span class="line">     <span class="type">NSString</span> * eventid = dic[@<span class="string">"ActionData"</span>][@<span class="string">"eventid"</span>]; </span><br><span class="line">     <span class="type">NSString</span> * targetname = dic[@<span class="string">"ActionData"</span>][@<span class="string">"target"</span>]; </span><br><span class="line">     <span class="type">NSString</span> * pageid = dic[@<span class="string">"ActionData"</span>][@<span class="string">"pageid"</span>]; </span><br><span class="line">     <span class="type">NSString</span> * pagename = dic[@<span class="string">"ActionData"</span>][@<span class="string">"pagename"</span>];</span><br><span class="line">     [<span class="type">AnalyticTool</span> upLoadActionEventWithScreenName:pagename withScreenID:pageid withTargetName:targetname withEventID:eventid]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>需要后台配合</li>
<li>可拓展性不是很高，因为需要修改后台下发的统计内容来每次的版本统计扩展</li>
</ol>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>相对于第一种方案，代码量少了很多。</li>
<li>动态化从后台获取统计内容，方便线上修改</li>
</ol>
<h3 id="无埋点"><a href="#无埋点" class="headerlink" title="无埋点"></a>无埋点</h3><p>无埋点，并不是不需要埋点，而更确切地说是“全埋点”，而且埋点代码不会出现在业务代码中，容易管理和维护。它的缺点在于，埋点成本高，后期的解析也比较复杂，再加上 view_path 的不确定性。所以，这种方案并不能解决所有的埋点需求，但对于大量通用的埋点需求来说，能够节省大量的开发和维护成本。</p>
<p>在这其中，可视化埋点和无埋点，都属于是无侵入的埋点方案，因为它们都不需要在工程代码中写入埋点代码。所以，采用这样的无侵入埋点方案，既可以做到埋点被统一维护，又可以实现和工程代码的解耦。</p>
<p>接下来，我们就通过今天这篇文章，一起来分析一下无侵入埋点方案的实现问题吧。</p>
<h3 id="运行时方法替换方式进行埋点"><a href="#运行时方法替换方式进行埋点" class="headerlink" title="运行时方法替换方式进行埋点"></a>运行时方法替换方式进行埋点</h3><p>我们都知道，在 iOS 开发中最常见的三种埋点，就是对页面进入次数、页面停留时间、点击事件的埋点。对于这三种常见情况，我们都可以通过运行时方法替换技术来插入埋点代码，以实现无侵入的埋点方法。具体的实现方法是：先写一个运行时方法替换的类 <code>ViewHook</code>，加上替换的方法 <code>hookClass:fromSelector:toSelector</code>，代码如下：</p>
<pre><code class="Swift">
#<span class="keyword">import</span> "ViewHook.h"
#<span class="keyword">import</span> &lt;objc/runtime.h&gt;

@implementation <span class="type">ViewHook</span>

+ (void)hookClass:(<span class="type">Class</span>)classObject fromSelector:(<span class="type">SEL</span>)fromSelector toSelector:(<span class="type">SEL</span>)toSelector {
    <span class="type">Class</span> <span class="class"><span class="keyword">class</span> = <span class="title">classObject</span>;</span>
<span class="class">    // 得到被替换类的实例方法</span>
<span class="class">    <span class="title">Method</span> <span class="title">fromMethod</span> = <span class="title">class_getInstanceMethod</span>(<span class="title">class</span>, <span class="title">fromSelector</span>);</span>
<span class="class">    // 得到替换类的实例方法</span>
<span class="class">    <span class="title">Method</span> <span class="title">toMethod</span> = <span class="title">class_getInstanceMethod</span>(<span class="title">class</span>, <span class="title">toSelector</span>);</span>
<span class="class"></span>
<span class="class">    // <span class="title">class_addMethod</span> 返回成功表示被替换的方法没实现，然后会通过 <span class="title">class_addMethod</span> 方法先实现；返回失败则表示被替换方法已存在，可以直接进行 <span class="title">IMP</span> 指针交换 </span>
<span class="class">    <span class="title">if</span>(<span class="title">class_addMethod</span>(<span class="title">class</span>, <span class="title">fromSelector</span>, <span class="title">method_getImplementation</span>(<span class="title">toMethod</span>), <span class="title">method_getTypeEncoding</span>(<span class="title">toMethod</span>))) </span>{
      <span class="comment">// 进行方法的替换</span>
        class_replaceMethod(<span class="class"><span class="keyword">class</span>, <span class="title">toSelector</span>, <span class="title">method_getImplementation</span>(<span class="title">fromMethod</span>), <span class="title">method_getTypeEncoding</span>(<span class="title">fromMethod</span>));</span>
<span class="class">    } <span class="title">else</span> </span>{
      <span class="comment">// 交换 IMP 指针</span>
        method_exchangeImplementations(fromMethod, toMethod);
    }

}

@end
</code></pre>
<p>这个方法利用运行时<code>method_exchangeImplementations</code>  接口将方法的实现进行了交换，原方法调用时就会被<code>hook</code>  住，从而去执行指定的方法。</p>
<p><strong>页面进入次数、页面停留时间都需要对 UIViewController 生命周期进行埋点</strong>，你可以创建一个 UIViewController 的 Category，代码如下：</p>
<pre><code class="Swift">
@implementation <span class="type">UIViewController</span> (logger)
+ (void)load {
    <span class="keyword">static</span> dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        <span class="comment">// 通过 @selector 获得被替换和替换方法的 SEL，作为 ViewHook:hookClass:fromeSelector:toSelector 的参数传入 </span>
        <span class="type">SEL</span> fromSelectorAppear = @selector(viewWillAppear:);
        <span class="type">SEL</span> toSelectorAppear = @selector(hook_viewWillAppear:);
        [<span class="type">ViewHook</span> hookClass:<span class="keyword">self</span> fromSelector:fromSelectorAppear toSelector:toSelectorAppear];

        <span class="type">SEL</span> fromSelectorDisappear = @selector(viewWillDisappear:);
        <span class="type">SEL</span> toSelectorDisappear = @selector(hook_viewWillDisappear:);

        [<span class="type">ViewHook</span> hookClass:<span class="keyword">self</span> fromSelector:fromSelectorDisappear toSelector:toSelectorDisappear];
    });
}

- (void)hook_viewWillAppear:(<span class="type">BOOL</span>)animated {
    <span class="comment">// 先执行插入代码，再执行原 viewWillAppear 方法</span>
    [<span class="keyword">self</span> insertToViewWillAppear];
    [<span class="keyword">self</span> hook_viewWillAppear:animated];
}
- (void)hook_viewWillDisappear:(<span class="type">BOOL</span>)animated {
    <span class="comment">// 执行插入代码，再执行原 viewWillDisappear 方法</span>
    [<span class="keyword">self</span> insertToViewWillDisappear];
    [<span class="keyword">self</span> hook_viewWillDisappear:animated];
}

- (void)insertToViewWillAppear {
    <span class="comment">// 在 ViewWillAppear 时进行日志的埋点</span>
    [[[[<span class="type">SMLogger</span> create]
       message:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@ Appear"</span>,<span class="type">NSStringFromClass</span>([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>])]]</span>
<span class="class">      <span class="title">classify</span>:<span class="title">ProjectClassifyOperation</span>]</span>
<span class="class">     <span class="title">save</span>];</span>
<span class="class">}</span>
<span class="class">- (<span class="title">void</span>)<span class="title">insertToViewWillDisappear</span> </span>{
    <span class="comment">// 在 ViewWillDisappear 时进行日志的埋点</span>
    [[[[<span class="type">SMLogger</span> create]
       message:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@ Disappear"</span>,<span class="type">NSStringFromClass</span>([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>])]]</span>
<span class="class">      <span class="title">classify</span>:<span class="title">ProjectClassifyOperation</span>]</span>
<span class="class">     <span class="title">save</span>];</span>
<span class="class">}</span>
<span class="class">@<span class="title">end</span></span></code></pre>
<p>可以看到，<code>Category</code>  在<code>+load()</code>  方法里使用了 ViewHook 进行方法替换，在替换的方法里执行需要埋点的方法 <code>[self insertToViewWillAppear]。</code> 这样的话，每个<code>UIViewController</code>  生命周期到了<code>ViewWillAppear</code> 时都会去执行<code>insertToViewWillAppear</code>  方法。</p>
<p>那么，我们要怎么区别不同的 <code>UIViewController</code> 呢？我一般采取的做法都是，使用<code>NSStringFromClass([self class])</code>  方法来取类名。这样，我就能够通过类名来区别不同的 <code>UIViewController</code>  了。</p>
<p><strong>对于点击事件来说，我们也可以通过运行时方法替换的方式进行无侵入埋点</strong>。这里最主要的工作是，找到这个点击事件的方法 sendAction:to:forEvent:，然后在 +load() 方法使用 ViewHook 替换成为你定义的方法。完整代码实现如下：</p>
<pre><code class="Swift">
+ (void)load {
    <span class="keyword">static</span> dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        <span class="comment">// 通过 @selector 获得被替换和替换方法的 SEL，作为 ViewHook:hookClass:fromeSelector:toSelector 的参数传入</span>
        <span class="type">SEL</span> fromSelector = @selector(sendAction:to:forEvent:);
        <span class="type">SEL</span> toSelector = @selector(hook_sendAction:to:forEvent:);
        [<span class="type">ViewHook</span> hookClass:<span class="keyword">self</span> fromSelector:fromSelector toSelector:toSelector];
    });
}

- (void)hook_sendAction:(<span class="type">SEL</span>)action to:(id)target forEvent:(<span class="type">UIEvent</span> *)event {
    [<span class="keyword">self</span> insertToSendAction:action to:target forEvent:event];
    [<span class="keyword">self</span> hook_sendAction:action to:target forEvent:event];
}
- (void)insertToSendAction:(<span class="type">SEL</span>)action to:(id)target forEvent:(<span class="type">UIEvent</span> *)event {
    <span class="comment">// 日志记录</span>
    <span class="keyword">if</span> ([[[event allTouches] anyObject] phase] == <span class="type">UITouchPhaseEnded</span>) {
        <span class="type">NSString</span> *actionString = <span class="type">NSStringFromSelector</span>(action);
        <span class="type">NSString</span> *targetName = <span class="type">NSStringFromClass</span>([target <span class="class"><span class="keyword">class</span>]);</span>
<span class="class">        [[[<span class="title">SMLogger</span> <span class="title">create</span>] <span class="title">message</span>:[<span class="title">NSString</span> <span class="title">stringWithFormat</span>:@"%@ %@",<span class="title">targetName</span>,<span class="title">actionString</span>]] <span class="title">save</span>];</span>
<span class="class">    }</span>
<span class="class">}</span></code></pre>
<p>和 UIViewController 生命周期埋点不同的是，UIButton 在一个视图类中可能有多个不同的继承类，相同 UIButton 的子类在不同视图类的埋点也要区别开。所以，我们需要通过 “action 选择器名NSStringFromSelector(action)” +“视图类名 NSStringFromClass([target class])”组合成一个唯一的标识，来进行埋点记录。</p>
<p>除了 UIViewController、UIButton 控件以外，Cocoa 框架的其他控件都可以使用这种方法来进行无侵入埋点。以 Cocoa 框架中最复杂的 UITableView 控件为例，你可以使用 hook setDelegate 方法来实现无侵入埋点。另外，对于 Cocoa 框架中的手势事件（Gesture Event），我们也可以通过 hook initWithTarget:action: 方法来实现无侵入埋点。</p>
<h2 id="事件唯一标识"><a href="#事件唯一标识" class="headerlink" title="事件唯一标识"></a>事件唯一标识</h2><p>通过运行时方法替换的方式，我们能够 hook 住所有的 Objective-C 方法，可以说是大而全了，能够帮助我们解决绝大部分的埋点问题。</p>
<p>但是，这种方案的精确度还不够高，还无法区分相同类在不同视图树节点的情况。比如，一个视图下相同 UIButton 的不同实例，仅仅通过 “action 选择器名”+“视图类名”的组合还不能够区分开。这时，我们就需要有一个唯一标识来区分不同的事件。接下来，我就跟你说说<strong>如何制定出这个唯一标识。</strong></p>
<p>这时，我首先想到的就是，能不能通过视图层级的路径来解决这个问题。因为每个页面都有一个视图树结构，通过视图的 superview 和 subviews 的属性，我们就能够还原出每个页面的视图树。视图树的顶层是 UIWindow，每个视图都在树的子节点上。如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/13/170d3eba9c53c6c8?w=1240&h=698&f=png&s=16105" alt="cbfb127db8ed2545fd3ce0aa3ae6f452.png"></p>
<p>一个视图下的子节点可能是同一个视图的不同实例，比如上图中 UIView 视图节点下的两个 UIButton 是同一个类的不同实例，所以光靠视图树的路径还是没法唯一确定出视图的标识。那么，这种情况下，我们又应该如何区别不同的视图呢？</p>
<p>这时，我们想到了索引：每个子视图在父视图中都会有自己的索引，所以如果我们再加上这个索引的话，每个视图的标识就是唯一的了</p>
<p>接下来的一个问题是，视图层级路径加上在父视图中的索引来进行唯一标识，是不是就能够涵盖所有情况了呢？</p>
<p>当然不是。我们还需要考虑类似 UITableViewCell 这种具有可复用机制的视图，Cell 会在页面滚动时不断复用，所以加索引的方式还是没法用。</p>
<p>但这个问题也并不是无解的。UITableViewCell 需要使用 indexPath，这个值里包含了 section 和 row 的值。所以，我们可以通过 indexPath 来确定每个 Cell 的唯一性。</p>
<p>除了 UITableViewCell 这种情况之外， UIAlertController 也比较特殊。它的特殊性在于视图层级的不固定，因为它可能出现在任何页面中。但是，我们都知道它的功能区分往往通过弹窗内容来决定，所以可以通过内容来确定它的唯一标识。</p>
<p>除此之外，还有更多需要特殊处理的情况，但我们总是可以通过一些办法去确定它们的唯一性，所以我在这里也就不再一一列举了。思路上来说就是，想办法找出元素间不相同的因素然后进行组合，最后形成一个能够区别于其他元素的标识来。</p>
<p>除了上面提到的这些特殊情况外，还有一种情况使得我们也难以得到准确的唯一标识。如果视图层级在运行时会被更改，比如执行 insertSubView:atIndex:、removeFromSuperView 等方法时，我们也无法得到唯一标识，即使只截取部分路径也无法保证后期代码更新时不会动到这个部分。就算是运行时视图层级不会修改，以后需求迭代页面更新频繁的话，视图唯一标识也需要同步的更新维护。</p>
<p>这种问题就不好解决了，事件唯一标识的准确性难以保障，这也是通过运行时方法替换进行无侵入埋点很难在各个公司全面铺开的原因。虽然无侵入埋点无法覆盖到所有情况，全面铺开面临挑战，但是无侵入埋点还是解决了大部分的埋点需求，也节省了大量的人力成本。</p>
<p>最好的方案永远是针对于不同的场景来说的，我们不可能在一个创业团队一开始就选择方案3的架构，所以对于你来说，你要自己抉择目前而言对你最好的方案，如果你没有后台业务同学的支持，方案1也许对你来说真的是最好的方案了，起码是可以完成统计需求，虽然苦点累点。但是在合适的时间，切换不同的选择，才是成长的体现，还是最开始的话，如果你在的团队，已经给你了资源和时间去完善埋点这个模块，如果你把它做的更好，那一定是一件很酷的事情。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://neyoufan.github.io/2017/04/19/ios/%E7%BD%91%E6%98%93HubbleData%E6%97%A0%E5%9F%8B%E7%82%B9SDK%E5%9C%A8iOS%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">网易HubbleData无痕埋点SDK实现</a></li>
<li><a href="https://www.jianshu.com/p/69ce01e15042" target="_blank" rel="noopener">iOS无埋点数据SDK实践之路</a></li>
<li><a href="https://tech.meituan.com/2017/03/02/mt-mobile-analytics-practice.html" target="_blank" rel="noopener">美团前端无痕埋点方案</a></li>
<li><a href="https://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">微信读书团队Aspects的基本原理</a></li>
<li><a href="http://ayeio.com/ios/2017/03/19/%E5%85%B3%E4%BA%8E-iOS%E6%89%93%E7%82%B9%E6%9D%82%E8%B0%88.html" target="_blank" rel="noopener">iOS打点杂谈</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/24/iOS%E6%97%A0%E4%BE%B5%E5%85%A5%E7%9A%84%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/" data-id="ckamlrppj0001xj769izgbew2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/MExuanHe.github.io/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/MExuanHe.github.io/2020/05/24/iOS%E9%99%8D%E4%BD%8EAPP%E5%B4%A9%E6%BA%83%E7%8E%87/">iOS降低APP崩溃率</a>
          </li>
        
          <li>
            <a href="/MExuanHe.github.io/2020/05/24/iOS%E6%97%A0%E4%BE%B5%E5%85%A5%E7%9A%84%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/">iOS无侵入的埋点方案如何实现？</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/MExuanHe.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/MExuanHe.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/MExuanHe.github.io/fancybox/jquery.fancybox.css">

  
<script src="/MExuanHe.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/MExuanHe.github.io/js/script.js"></script>




  </div>
</body>
</html>