<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>背水一战</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="背水一战">
<meta property="og:url" content="https://github.com/MExuanHe/MExuanHe.github.io/index.html">
<meta property="og:site_name" content="背水一战">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/MExuanHe.github.io/atom.xml" title="背水一战" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/MExuanHe.github.io/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/MExuanHe.github.io/" id="logo">背水一战</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/MExuanHe.github.io/">Home</a>
        
          <a class="main-nav-link" href="/MExuanHe.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/MExuanHe.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/MExuanHe/MExuanHe.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-项目工程自动化 - OCLint" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/26/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96%20-%20OCLint/" class="article-date">
  <time datetime="2020-05-25T16:48:32.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/26/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96%20-%20OCLint/">OCLint</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>为了保证代码质量，Code Review 是非常重要的一环，受限于现实情况，大多数团队没有足够的时间进行 Code Review，那么只能把一部分 CR 工作交给计算机去完成了。我们只需要定下合理的流程，用代码告诉计算机需要做什么，剩下的就交给我们可靠的伙伴吧。</p>
<p>应用了自动化 Code Review 后，如果你的代码写得不好，Xcode 会表示不开心。<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c6e6df309f1.png" alt="aaaa.png"></p>
<p>如果你忽略 Xcode 的心情，那么质量管理平台会默默地记录这一切</p>
<p><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/1724cbe9d51d2a49.png" alt="aaaa.png"></p>
<p>这套东西既帮助开发们写出更高质量的的代码，也给经理们对工程质量的评估提供了一个切面的支持，同时只需要花费较少的人力维护</p>
<h2 id="OCLint"><a href="#OCLint" class="headerlink" title="OCLint"></a>OCLint</h2><p><strong>工欲善其事，必先利其器</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/26/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96%20-%20OCLint/" data-id="ckamqc2zc00046z76hygb1q4a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-组件之间的通讯（Target-Action）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/26/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%EF%BC%88Target-Action%EF%BC%89/" class="article-date">
  <time datetime="2020-05-25T16:46:02.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/26/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%EF%BC%88Target-Action%EF%BC%89/">组件之间的通讯（Target-Action）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是组件间通讯"><a href="#什么是组件间通讯" class="headerlink" title="什么是组件间通讯?"></a>什么是组件间通讯?</h1><ul>
<li>比如现在有很多业务组件, 在另外一个组件内部需要调用另外一个组件中的服务, 或者打开另外一个组件中的控制器, 并传值</li>
</ul>
<p><strong>iOS业界讨论组件化方案甚多，大体来说有3种。</strong></p>
<ul>
<li>Protocol注册方案</li>
<li>URL注册方案</li>
<li>Target-Action runtime调用方案</li>
</ul>
<h4 id="MGJRoute方案"><a href="#MGJRoute方案" class="headerlink" title="MGJRoute方案"></a>MGJRoute方案</h4><p>URL注册方案 <strong><a href="https://link.jianshu.com/?t=http://limboy.me/tech/2016/03/10/mgj-components.html" target="_blank" rel="noopener">蘑菇街 App 的组件化之路</a></strong> 已经说的很清楚了 可以去看下</p>
<p>原理：</p>
<ul>
<li>通过url注册服务, 其他地方通过url, 获取服务</li>
<li>框架在维护一个url-block的表格</li>
</ul>
<p>特点：</p>
<ul>
<li>每个业务组件, 都需要依赖这个框架</li>
<li>url维护成本高 硬解码</li>
<li>可以在组件内部任何地方调用/注册服务, 没有必要统一组件接口服务</li>
</ul>
<h4 id="target-action方案"><a href="#target-action方案" class="headerlink" title="target-action方案"></a>target-action方案</h4><p>原理：</p>
<ul>
<li>每个组件, 提供一个统一披露的接口文件</li>
<li>额外的维护一个中间件的分类扩展（在此处进行硬解码 通过运行时进行物理解耦）</li>
<li>其他地方通过target-action;的方案进行交互</li>
</ul>
<p>特点：</p>
<ul>
<li>集约</li>
<li>统一了组件api服务</li>
<li>组件与框架之间无依赖关系</li>
<li>需要额外维护中间件类扩展</li>
</ul>
<h4 id="Protocol方案-暂无了解"><a href="#Protocol方案-暂无了解" class="headerlink" title="Protocol方案  暂无了解"></a>Protocol方案  暂无了解</h4><h2 id="本文-主要讲解-target-action-方案"><a href="#本文-主要讲解-target-action-方案" class="headerlink" title="本文 主要讲解 target-action 方案"></a>本文 主要讲解 <a href="https://github.com/MExuanHe/Target-Action-Dome">target-action</a> 方案</h2><p><strong>侵入性问题</strong><br>正如你所见，CTMediator组件化方案的实施非常安全。因为它并不存在任何侵入性的代码修改。<br>对于响应者来说，什么代码都不用改，只需要包一层Target-Action即可。<br>对于调用者来说，只需要把调用方式换成CTMediator调用即可，其改动也不涉及原有的业务逻辑，所以是十分安全的。</p>
<p><strong>注册问题</strong><br>CTMediator没有任何注册逻辑的代码，避免了注册文件的维护和管理。Category给到的方法很明确地告知了调用者应该如何调用。</p>
<p>例如给到的</p>
<pre><code>- (UIViewController *)goodsDetailViewControllerWithGoodsId:(NSString *)goodsId goodsName:(NSString *)goodsName;</code></pre><p>方法。这能够让工程师一眼就能够明白使用方式，而不必抓瞎拿着URL再去翻文档。<br>这可以很大程度提高工作效率，同时降低维护成本。</p>
<p>下面是我做的项目Dome结构<img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34cb1e0b80dee.png" alt="Snip20180403_5.png"></p>
<p>我们主要是依赖<code>CTMediator</code>  这个中间件 </p>
<p>工具类中主要使用如下方法</p>
<pre><code>- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget</code></pre><p>方法内部使用Runtime调用  需要传三个参数 </p>
<ul>
<li>当前需要调用的类名  （字符串）</li>
<li>当前需要调用类的方法名 （字符串）</li>
<li>需要传的参数 （字典形式） </li>
</ul>
<pre><code># 通过Runtime  把字符串 转换类
Class targetClass = NSClassFromString(ClassString);
id  target = [[targetClass alloc] init];

# 把字符串转换成事件
SEL action = NSSelectorFromString(actionString);

# 如果当前类中有这个事件 那就执行这个事件 把需要的参数传值 
if ([target respondsToSelector:action]) {
    return [target performSelector:action withObject:params];
} </code></pre><p>下面是一个组件的结构<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34cb1e5814e97.png" alt="Snip20180403_6.png"></p>
<p>我们当前 <code>TAConfirmOrder</code>  组件中</p>
<ul>
<li><code>TAConfirmOrderViewController</code> 是业务组件 </li>
<li><code>Target_TAConfirmOrder</code> 是每个组件, 提供一个统一披露的接口文件  </li>
<li><code>CTMediator+TAConfirmOrder</code> 是额外的维护一个中间件的分类扩展</li>
<li>组件与框架之间无依赖关系，我们需要额外维护中间件类扩展就可以了</li>
</ul>
<p>我们只需要把类名和类中的方法名 告诉这个分类扩展就行了<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34cb1e570d952.png" alt="Snip20180403_7.png"></p>
<p>最后  <a href="https://github.com/MExuanHe/Target-Action-Dome">Dome 地址</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/26/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%EF%BC%88Target-Action%EF%BC%89/" data-id="ckamqc2za00026z766lyrdyb0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-组件化实战篇（私有库）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/26/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%88%E7%A7%81%E6%9C%89%E5%BA%93%EF%BC%89/" class="article-date">
  <time datetime="2020-05-25T16:37:55.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/26/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%88%E7%A7%81%E6%9C%89%E5%BA%93%EF%BC%89/">组件化实战篇（私有库）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a><strong>前沿</strong></h1><p>本片文章主要讲解我们项目中为什么要组件化  组件化的好处 怎么使用组件化  怎么实现组件化</p>
<h1 id="为什么要组件化"><a href="#为什么要组件化" class="headerlink" title="为什么要组件化"></a><strong>为什么要组件化</strong></h1><ul>
<li>随着项目的更新迭代  项目代码越来越复杂   每个模块之间相互依赖 更改一处代码 有可能要更改跟这段代码耦合度非常高的多处代码 导致增加了我们的开发时间  增加了不必要的麻烦 </li>
<li>使用组件化 可以把业务模块 共同的功能性代码和基础代码 分离出来 单独管理  每个开发人员只负责维护自己的模块就可以了  不仅节省了开发周期  还大大降低了维护成本</li>
</ul>
<h1 id="组件化的细想"><a href="#组件化的细想" class="headerlink" title="组件化的细想"></a><strong>组件化的细想</strong></h1><p> 就好比封装控件，复杂的控件一般都会封装，组件化只不过是把每个模块单独抽出来，作为一个小工程，然后在组成一个一个完整的项目</p>
<h1 id="组件化的实现"><a href="#组件化的实现" class="headerlink" title="组件化的实现"></a><strong>组件化的实现</strong></h1><ul>
<li>在项目当中我们使用Cocoapod来管理我们的组件化开发</li>
</ul>
<ol>
<li><p>打开终端 创建一个XXX项目工程<br>cd 到一个文件跟目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置下工程信息<img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c82e48c81b1.png" alt="3f7f401-5c21-4ac9-9c8c-e7640ec11d81.png"></p>
</li>
<li><p>工程配置完成 我们把我们需要的项目组件拖入到我们工程的Classes文件中  然后 cd 进入到Example 文件中 <code>pod install</code> 安装下我们的组件 <img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c82e92cdb69.png" alt="Snip20180402_9.png"></p>
</li>
</ol>
<p>为什么要<code>pod install</code>,因为不重新<code>pod install</code>   Example工程根本不知道Pod更新了，<code>pod install</code>的作用：重新让pod库与所依赖的工程文件产生关联<br>打开  Example 文件中的项目 Command+B 一下 如果没有问题 就说明集成成功</p>
<ol start="4">
<li>配置描述文件   <strong>podspec</strong><br>这里需要重点说一下 <strong>podspec 文件</strong>  </li>
</ol>
<p><strong>podspec</strong> : 描述自己组件工程的代码目录和资源目录在哪，还有自己组件工程所依赖其他框架，到时候就会根据podspec的指引去引入自己的仓库代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建pod索引库，固定写法,并且定义索引库的名字为s,后续通过s，就能拿到索引库</span><br><span class="line">    Pod::Spec.new do |s|</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 设置名称</span><br><span class="line">      s.name         &#x3D; &quot;tcggMain&quot;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 设置版本号</span><br><span class="line">      s.version      &#x3D; &quot;0.0.1&quot;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 设置摘要</span><br><span class="line">      s.summary      &#x3D; &quot;A short description of tcggMain.&quot;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 设置详情</span><br><span class="line">      s.description  &#x3D; &quot;Good&quot;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 设置仓库主页</span><br><span class="line">      s.homepage     &#x3D; &quot;http:&#x2F;&#x2F;xxxx&#x2F;xxxx&quot;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 设置许可证</span><br><span class="line">      s.license      &#x3D; &quot;MIT&quot;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 设置作者</span><br><span class="line">      s.author             &#x3D; &#123; &quot;iThinkerYZ&quot; &#x3D;&gt; &quot;xxxx@qq.com&quot; &#125;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 设置仓库源,表示在哪可以找到组件工程</span><br><span class="line">      s.source       &#x3D; &#123; :git &#x3D;&gt; &quot;xxxxx&quot;, :tag &#x3D;&gt; &quot;#&#123;s.version&#125;&quot; &#125;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; 设置 源文件路径 &#x3D;&gt; 不是整个工程的文件，而是自己封装的代码，以后别的工程引入，就会引入这里的代码。</span><br><span class="line">      s.source_files  &#x3D; &quot;tcggMain&#x2F;Classes&#x2F;**&#x2F;*.&#123;h,m&#125;&quot;</span><br><span class="line">    </span><br><span class="line">     &#x2F;&#x2F; s.dependency &#x3D; &#39;&#39; 组件工程依赖哪些第三方框架</span><br><span class="line">     &#x2F;&#x2F; s.frameworks &#x3D; &#39;UIKit&#39;, &#39;MapKit&#39; 组件工程依赖哪些原生框架</span><br><span class="line">     &#x2F;&#x2F; s.resource_bundles &#x3D; &#123;&#125; 组件工程图片资源</span><br><span class="line">     </span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/f841e248bc4f" target="_blank" rel="noopener">PodSpec</a></p>
<ol start="5">
<li>本地组件配置完成之后 就需要把本地的组件上传的远程私有仓库（ 上传的代码就不贴出来了 网上有很多 ）</li>
</ol>
<p><strong>注意点</strong>：<code>push</code> 远程仓库的时候 一定要打<code>tag</code>  并且<code>tag</code>的版本号要跟Spec文件中 <code>s.version</code> 的版本号一致 因为cocoapods是根据代码仓库的<code>tag</code>,去下载对应<code>tag</code>的远程代码库的</p>
<p>6.在本地Cocoapods索引库中创建我们私有组件的索引库文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo add 私有组件名称 索引库远程地址</span><br><span class="line">pod repo add TcggBase https:&#x2F;&#x2F;git.coding.net&#x2F;XUser&#x2F;TccBase.git</span><br></pre></td></tr></table></figure>
<p>如果不想使用命令行输入的话  我们也可以手动创建<br> –  找到本地的cocoapods 的地址  在 <code>repos</code> 文件中创建一个 <code>TcggBase</code> 文件<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c82e974dd06.png" alt="Snip20180402_14.png"></p>
<ol start="7">
<li>把自己私有库的索引添加到自己私有库中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod repo push 索引库名称 当前组件中podspec文件全称</span><br><span class="line">pod repo push TcggBase TcggBase.podspec --allow-warnings</span><br></pre></td></tr></table></figure>
本地索引库就会有自己的私有库，并且远程也会有，<code>pod repo push</code>    会帮我们推送到远程索引库<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c82ea6a9dec.png" alt="Snip20180402_15.png"></li>
</ol>
<p>打开本地cocoapods中自己的私有库索引地址 发现里面已经有了 我们自己的私有库索引  <code>0.1.0 是我们的版本号 cocoapod 会根据Spec文件中的tag 创建相对应的文件名称</code></p>
<p>如果 <code>Push</code> 中出现的错误 我们也可以手动去上传<br>在cocoapods 本地索引库中 找到我们自己创建的索引库  在我们自己创建的索引库中 我们手动创建我们跟当前Spec文件中 描述的版本号相符的文件  文件名字就是我们当前组件的版本号   在把我们自己组件中的Spec文件复制 拷贝到当前的文件中去 就行了</p>
<p>######使用自己的私有索引仓库<br>在 <code>Podfile</code>  文件中 添加两个 source 一个是cocoapods 公有的索引库源  一个是我们自己的索引库源  然后我们在<code>pod &#39;xxx&#39;</code>  <code>pod install</code>  就可以了<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c82e8ccb385.png" alt="Snip20180402_17.png"></p>
<h1 id="组件化升级"><a href="#组件化升级" class="headerlink" title="组件化升级"></a>组件化升级</h1><ul>
<li>只需要把最新的版本代码绑定tag,更新Podspec文件，重新上传到版本索引库就好了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push xxxx xxxx.podspec --allow-warnings</span><br></pre></td></tr></table></figure></li>
<li>工程文件在使用的时候，使用pod update 就能加载最新版本组件代码.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update --no-repo-update</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Cocopods原理"><a href="#Cocopods原理" class="headerlink" title="Cocopods原理"></a>Cocopods原理</h1><p>1.根据Podfile描述，找到对应代码库的描述文件podspec<br>2.podspec中描述，去哪（s.source）才能找到代码库，并且找到之后，需要拷贝哪些文件（s.source_files）到自己的工程中。</p>
<h1 id="组件化中遇到的一些问题"><a href="#组件化中遇到的一些问题" class="headerlink" title="组件化中遇到的一些问题"></a>组件化中遇到的一些问题</h1><h6 id="加载XIB文件报错"><a href="#加载XIB文件报错" class="headerlink" title="加载XIB文件报错"></a>加载XIB文件报错</h6><p><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c82ea5e3fe4.png" alt="02576880-5A64-4125-AD02-2D6639931103.png"></p>
<p>回到代码查看一下，原来加载XIB的方式如下<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c8308a7f943.png" alt="BC46FF90-7496-4DB7-86D0-BD080AF2AB9C.png"><br>显然通过加载上面的bundle的方式加载不到XIB，需要重新设置budle的路径，修改如下：<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c830cbf6450.png" alt="55D1EFCD-B138-4AF9-B5BB-DD8F7878BFB1.png"></p>
<h3 id="图片资源加载问题"><a href="#图片资源加载问题" class="headerlink" title="图片资源加载问题"></a>图片资源加载问题</h3><p>把组件中需要的图片存放到<code>Assets</code>中<img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c830cb5ec76.jpeg" alt="4A887AAA-B538-464B-A71E-5E6E8DBAD536.png"></p>
<p>需要修改<code>.podspec</code>文件，打开资源的加载路径，然后执行<code>pod install</code>。然后会发现多了一个<code>Resource</code>的资源文件夹<img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c830ecec917.jpeg" alt="FD4D7ECF-48C2-47BE-BBF6-9C708C6B0B70.png"></p>
<p>需要改变图片的加载方式<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c83125f00a0.jpeg" alt="94BC756A-0218-4662-BB14-5FEC4FC9E532.png"></p>
<p>说明：必须指明图片的全名和图片所在<code>bundle</code>的包名<br>因为涉及到@2x，@3x图片这里不能写成固定的，应该按照scale来设置<img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34c83141fa7b9.jpeg" alt="02A9C836-51EF-4CC4-A26D-F346904B8717.png"></p>
<p>因为之前设置图片的方式都需要修改，上面修改图片加载方式的代码在很多地方都会用到，所以最好的做法就是抽取一个工具方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)ff_imagePathWithName:(NSString *)imageName bundle:(NSString *)bundle targetClass:(Class)targetClass</span><br><span class="line">&#123;</span><br><span class="line">        NSInteger scale &#x3D; [[UIScreen mainScreen] scale];</span><br><span class="line">        NSBundle *currentBundle &#x3D; [NSBundle bundleForClass:targetClass];</span><br><span class="line">        NSString *name &#x3D; [NSString stringWithFormat:@&quot;%@@%zdx&quot;,imageName,scale];</span><br><span class="line">        NSString *dir &#x3D; [NSString stringWithFormat:@&quot;%@.bundle&quot;,bundle];</span><br><span class="line">        NSString *path &#x3D; [currentBundle pathForResource:name ofType:@&quot;png&quot; inDirectory:dir];</span><br><span class="line">        return path ? [UIImage imageWithContentsOfFile:path] : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h3><p>将字体相关文件也拖入到<code>Assets</code>文件夹下，然后修改一下<code>podspec</code>文件。最后执行<code>pod install</code>把字体资源<code>pod</code>进来。<br>接着在原来设置字体的地方做相应的修改，和修改图片资源路径的方式相似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_categoryLabel &#x3D; [[UILabel alloc]init];</span><br><span class="line"> NSBundle *currentBundle &#x3D; [NSBundle bundleForClass:[self class]];</span><br><span class="line"> NSString *path &#x3D; [currentBundle pathForResource:@&quot;CODE BOLD.OTF&quot; ofType:nil inDirectory:@&quot;FFSpecialKit”];</span><br><span class="line"> [_categoryLabel text:nil textColor:kHexColor_c7a762 fontSize:FONT_SIZE_14 fontName:path];</span><br></pre></td></tr></table></figure>

<h5 id="下一篇"><a href="#下一篇" class="headerlink" title="下一篇"></a>下一篇</h5><p><strong><a href="https://www.jianshu.com/p/596d4efbbccb" target="_blank" rel="noopener">组件化之间的通讯</a></strong> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/26/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%88%E7%A7%81%E6%9C%89%E5%BA%93%EF%BC%89/" data-id="ckamqc2zb00036z76382g6wx2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA（本地服务器配置微信支付）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/26/JAVA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%EF%BC%89/" class="article-date">
  <time datetime="2020-05-25T16:32:33.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/26/JAVA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%EF%BC%89/">JAVA（本地服务器配置微信支付）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><p>我是一名iOS开发者 最近由于工作的原因 由我来处理服务器后台集成第三方支付的功能 语言是Java 顺水推舟 就学了下 Java语法 </p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>需要的工具 ：</p>
<ul>
<li>JDK：Java 开发包 <a href="https://download.csdn.net/download/tan3739/9476575" target="_blank" rel="noopener">下载地址</a></li>
<li>Eclipse ： 服务器开发工具  <a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">下载地址</a></li>
<li>Tomcat ：服务器运行环境   <a href="http://tomcat.apache.org" target="_blank" rel="noopener">下载地址</a></li>
</ul>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>打开Eclipse 首先要配置下我们的Tomcat     <a href="http://jingyan.baidu.com/article/3065b3b6efa9d7becff8a4c6.html" target="_blank" rel="noopener">教程</a></p>
<ul>
<li>创建动态Web项目<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34cbdc9a4f9ec.png" alt="Snip20180410_2.png"></li>
</ul>
<p>配置 Web Project  我的Tomcat是8.0 就选择8.0<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34cbdce41c1a2.png" alt="Snip20180410_5.png"></p>
<p>文件目录<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34cbdcdd7f2ef.png" alt="Snip20180410_9.png"></p>
<p><strong>需要说明下</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在WebContent中的lib文件目录下 存放我们的jar 文件</span><br><span class="line">在Java Resources 目录下 存放我们的代码文件</span><br></pre></td></tr></table></figure></p>
<p>把这两个工具文件拖入到项目中 方便我们快速开发 工具文件我会放到Github上面 <img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34cbdce7404fa.png" alt="Snip20180410_10.png"></p>
<ul>
<li><p>创建接口文件<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34cbdcded075d.png" alt="Snip20180410_11.png"></p>
<figure class="highlight plain"><figcaption><span>是选择哪个文件目录下面</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;Superclass&#96;&#96;&#96; 选择继承&#96;&#96;&#96;HttpServlet</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/16a34cbdce9704bf.png" alt="Snip20180410_13.png"></p>
</li>
</ul>
<p>接下来就可以写我们的接口代码了</p>
<p> 创建几个参数 把相应的信息填写进去</p>
<pre><code>// 微信开发平台应用id
public static String APP_ID = &quot;&quot;;
// 财付通商户号
public static String PARTNER_ID = &quot;&quot;;
// 商户号对应的密钥
public static String PARTNER_KEY = &quot;&quot;;
// 统一下单
public static String URL_UNIFIEDORDER = &quot;&quot;;
// 接收财付通通知的URL
public static String NOTIFY_URL = &quot;&quot;;</code></pre><p>在 <code>doPost</code> 方法里面处理我们的订单签名</p>
<p>1.填写签名订单信息</p>
<ul>
<li>初始化<code>PrepayIdRequestHandler</code> 类  微信写好一个封装案例,你可以根据服务器需求，自己定义网络请求框架<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrepayIdRequestHandler handler &#x3D;new PrepayIdRequestHandler(req, resp);</span><br></pre></td></tr></table></figure>
<ul>
<li>填写相应的参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 统一下单的接口(调用微信支付服务器需要的接口)---&gt;公开的</span><br><span class="line">handler.setGateUrl(URL_UNIFIEDORDER);</span><br><span class="line">&#x2F;&#x2F; 设置密钥</span><br><span class="line">handler.setKey(PARTNER_KEY);</span><br><span class="line">&#x2F;&#x2F; 设置应用的ID</span><br><span class="line">handler.setParameter(&quot;appid&quot;, APP_ID);</span><br><span class="line">根据微信文档的要求 填写相应的信息  这里我就不往下写相应的参数信息了 微信文档写的很清楚</span><br><span class="line">唯一想提的是  setParameter 方法就跟iOS里面设置字典一样 都是key和Value</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>2.调用微信统一下单接口(目的：获取prepay_id)</p>
<ul>
<li>调用 <code>sendPrepay</code> 方法获取 <code>prepay_id</code>  这里微信返回的数据是XML数据格式  <code>sendPrepay</code> 方法 返回的是一个Map 集合 在iOS里面就叫做 字典<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map paramsMap &#x3D; handler.sendPrepay();</span><br><span class="line">String prepay_id &#x3D; (String) paramsMap.get(&quot;prepay_id&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>处理接口返回信息进行二次签名</p>
<ul>
<li>这里需要注意的是 二次签名和一次签名，参数不一样 注意官网文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">OrderResult orderResult&#x3D;new OrderResult();</span><br><span class="line">&#x2F;&#x2F;清空集合  重新 赋值</span><br><span class="line">handler.clear();</span><br><span class="line">String noncestr &#x3D; (String) paramsMap.get(&quot;noncestr&quot;);</span><br><span class="line">String timestamp &#x3D; WXUtil.getTimeStamp();</span><br><span class="line">&#x2F;&#x2F; 密钥</span><br><span class="line">handler.setKey(PARTNER_KEY);</span><br><span class="line">&#x2F;&#x2F; 设置应用的ID</span><br><span class="line">handler.setParameter(&quot;appid&quot;, APP_ID);</span><br><span class="line">&#x2F;&#x2F; 预付单ID</span><br><span class="line">handler.setParameter(&quot;prepayid&quot;, prepay_id);</span><br><span class="line">&#x2F;&#x2F; 扩展字段</span><br><span class="line">handler.setParameter(&quot;package&quot;, &quot;Sign&#x3D;WXPay&quot;);</span><br><span class="line">&#x2F;&#x2F; 商户号</span><br><span class="line">handler.setParameter(&quot;partnerid&quot;, PARTNER_ID);</span><br><span class="line">&#x2F;&#x2F; 随机字符串</span><br><span class="line">handler.setParameter(&quot;noncestr&quot;, noncestr);</span><br><span class="line">&#x2F;&#x2F; 时间戳</span><br><span class="line">handler.setParameter(&quot;timestamp&quot;, timestamp);</span><br><span class="line">&#x2F;&#x2F; 进行二次签名(签名参数不一样)</span><br><span class="line">&#x2F;&#x2F; 第一次签名：对订单信息签名，获取prepay_id</span><br><span class="line">&#x2F;&#x2F; 第二次签名：对支付信息进行签名</span><br><span class="line">sign &#x3D; handler.createMD5Sign();</span><br><span class="line"></span><br><span class="line">OrderBean orderBean &#x3D; new OrderBean();</span><br><span class="line"></span><br><span class="line">orderBean.setAppid(APP_ID);</span><br><span class="line">orderBean.setNoncestr(noncestr);</span><br><span class="line">orderBean.setPackageValue(&quot;Sign&#x3D;WXPay&quot;);</span><br><span class="line">orderBean.setPartnerid(PARTNER_ID);</span><br><span class="line">orderBean.setPrepayid(prepay_id);</span><br><span class="line">orderBean.setTradeType((String) paramsMap.get(&quot;trade_type&quot;));</span><br><span class="line">orderBean.setSign(sign);</span><br><span class="line">orderBean.setTimestamp(timestamp);			</span><br><span class="line">orderResult.setOrderBean(orderBean);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>将model转json数据格式 返回客户单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Gson gson&#x3D;new Gson();</span><br><span class="line">&#x2F;&#x2F;解析成json字符串</span><br><span class="line">String jsonstr&#x3D;gson.toJson(orderResult);</span><br><span class="line">resp.getWriter().print(jsonstr);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>以上java服务器端微信支付代码完成  客服端的代码我就不贴了</strong><br><a href="https://github.com/MExuanHe/WxPay-java">dome地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/26/JAVA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%EF%BC%89/" data-id="ckamqc2z800016z760vzval2o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AVFoundation入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/26/AVFoundation%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2020-05-25T16:31:50.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/26/AVFoundation%E5%85%A5%E9%97%A8/">AVFoundation入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a><strong>前沿</strong></h1><p>随着移动技术的成熟和即将到来的5G时代 ，越来越多的公司开发移动视频软件来占领市场，随着抖音的登场 视频APP现已是火海一片，BAT纷纷入场。<br>为了能在红海中分一杯羹 我司决定开发一款赛马的视频观看项目，在项目的开发中  对苹果的AVFoundation框架进行了了解和学习 在学习过程中越来越佩服<code>AVFoundation</code>框架的厉害之处。我会分几篇文章来分析<code>AVFoundation</code>中常用的API和类</p>
<h1 id="AVFoundation入门"><a href="#AVFoundation入门" class="headerlink" title="AVFoundation入门"></a><strong>AVFoundation入门</strong></h1><p>在学习<code>AVFoundation</code>之初，最大的挑战就是理解该框架所提供的大量类及其功能。该框架包含的类超过100个、大量协议的集合及许多不同的功能和常量。在第一次遇到这些问题时看似掌握这个框架有一定的难度， 但是如果你将这个框架仔细地按功能单元进行分解，就会变得比较容易理解。下面就看一下 AVFoundation所提供的一些核心功能。</p>
<ul>
<li><h5 id="音频播放和记录"><a href="#音频播放和记录" class="headerlink" title="音频播放和记录"></a>音频播放和记录</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ##### 媒体文件检查</span><br><span class="line">&#96;&#96;&#96;AVFoundation&#96;&#96;&#96;提供检查正在使用的媒体文件的功能。可以查看这些媒体资源来确定是否适合一些特定的任务，比如是否可以用于回放或其是否可以被编辑和导出。还可以获取该媒体资源相关的技术参数，比如内容持续时间  创建日期或首选播放音量等。此外，该框架还基于&#96;&#96;&#96;AVMetadataItem&#96;&#96;&#96;类提供功能强大的元数据支持。这就允许开发者读写关于媒体资源的描述信息。</span><br><span class="line"></span><br><span class="line">- ##### 视频播放</span><br><span class="line">&#96;&#96;&#96;AVFoundation&#96;&#96;&#96;框架可以让你播放从本地文件或远程流中获取的视频资源，并对视频播放和内容的展示进行控制。这一部分的核心类是&#96;&#96;&#96;AVPlayer&#96;&#96;&#96;和&#96;&#96;&#96;AVPlayerItem&#96;&#96;&#96;，正是这两个类让你能够对资源的播放进行控制，此外它还可以整合其他更高级的功能，如控制子标题和章节信息等。或者让你链接访问音频和视频这两个不同的资源。</span><br><span class="line"></span><br><span class="line">- ##### 媒体捕捉</span><br><span class="line">&#96;&#96;&#96;AVFoundation&#96;&#96;&#96;提供了一个丰富的API集来让你可以对这些设备进行精密控制。摄像头捕捉的核心类是&#96;&#96;&#96;AVCaptureSession&#96;&#96;&#96;，其作为所有活动的汇集点来接收摄像头设备由各路流发过来的电影和图片。这也是&#96;&#96;&#96;AVFoundation&#96;&#96;&#96;框架的一个可靠功能。</span><br><span class="line"></span><br><span class="line">- ##### 媒体编辑</span><br><span class="line">&#96;&#96;&#96;AVFoundation&#96;&#96;&#96;框架语允许创建可以将多个音频和视频资源进行组合的应用程序，允许修改和编辑独立的媒体片段，随时修改音频文件的参数以及添加动画标题和场景切换效果。</span><br><span class="line">&#96;&#96;&#96;AVFoundation&#96;&#96;&#96;有关资源组合的功能源于&#96;&#96;&#96;AVAsset&#96;&#96;&#96;的子类&#96;&#96;&#96;AVComposition&#96;&#96;&#96;。&#96;&#96;&#96;AVComposition&#96;&#96;&#96;中的轨道都是&#96;&#96;&#96;AVAssetTrack&#96;&#96;&#96;的子类&#96;&#96;&#96;AVCompositionTrack&#96;&#96;&#96;。一个组合轨迹本身由一个或多个媒体片断组成，由&#96;&#96;&#96;AVCompositionTrackSegment&#96;&#96;&#96;类定义，代表这个组合中的实际媒体区域，描述如下图所示：</span><br><span class="line">![20170914231445643.png](https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2019&#x2F;4&#x2F;19&#x2F;16a34cca12ca8ccf?w&#x3D;1240&amp;h&#x3D;352&amp;f&#x3D;png&amp;s&#x3D;89258)</span><br><span class="line">&#96;&#96;&#96;AVComposition&#96;&#96;&#96;和&#96;&#96;&#96;AVCompositionTrack&#96;&#96;&#96;都是不可变对象，提供对资源的只读操作。这些对象提供了一个合适的接口让应用程序的一部分可以进行播放或处理。但当需要创建自己的组合时，就需要使用&#96;&#96;&#96;AVMutableComposition&#96;&#96;&#96;和&#96;&#96;&#96;AVMutableCompositionTrack&#96;&#96;&#96;所提供的可变子类。要创建自定义组合，需指定在将要添加到组合的源媒体的时间范围，还要指定要添加片段的每个轨道的位置。</span><br><span class="line"></span><br><span class="line">- ##### 媒体处理</span><br><span class="line">虽然通过&#96;&#96;&#96;AVFoundation&#96;&#96;&#96;框架可以在不通过对媒体资源字节一级进行操作的前提下实现大量功能，但有时你可能还是需要访问更低层的数据并对其进行操作。幸运的是，当需要执行更高级的媒体处理任务时，可以使用&#96;&#96;&#96;AVAssetReader&#96;&#96;&#96; 和&#96;&#96;&#96;AVAssetWriter&#96;&#96;&#96;类来实现这些功能。这些类提供直接访问视频帧和音频样本的功能，所以可以对媒体资源进行任何更高级的处理。</span><br><span class="line"></span><br><span class="line"># **视频的基本知识点**</span><br><span class="line"></span><br><span class="line">* 流媒体开发： 网络层(socket或st)负责传输，协议层(rtmp或hls)负责网络打包，封装层(flv、ts)负责编解码数据的封装，编码层(h.264和aac)负责图像，音频压缩。</span><br><span class="line">* 帧：每帧代表一幅静止的图像</span><br><span class="line">* GOP: （&#96;&#96;&#96;Group of Pictures&#96;&#96;&#96;）画面组，一个GOP就是一组连续的画面，每个画面都是一帧，一个GOP就是很多帧的集合.     (直播的数据，其实是一组图片，包括I帧、P帧、B帧，当用户第一次观看的时候，会寻找I帧，而播放器会到服务器寻找到最近的I帧反馈给用户。因此，GOP Cache增加了端到端延迟，因为它必须要拿到最近的I帧). GOP Cache的长度越长，画面质量越好    </span><br><span class="line">* 码率： 图片进行压缩后每秒显示的数据量。</span><br><span class="line">* 帧率： 每秒显示的图片数。影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。（由于人类眼睛的特殊生理结构，如果所看画面之帧率高于16的时候，就会认为是连贯的，此现象称之为视觉暂留。并且当帧速达到一定数值后，再增长的话，人眼也不容易察觉到有明显的流畅度提升了。）</span><br><span class="line">* 分辨率：（矩形)图片的长度和宽度，即图片的尺寸</span><br><span class="line">* 压缩前的每秒数据量：帧率X分辨率(单位应该是若干个字节)</span><br><span class="line">* 压缩比：压缩前的每秒数据量&#x2F;码率 （对于同一个视频源并采用同一种视频编码算法，则：压缩比越高，画面质量越差。）</span><br><span class="line">* 视频文件格式：文件的后缀，比如&#96;&#96;&#96;.wmv&#96;&#96;&#96;,&#96;&#96;&#96;.mov&#96;&#96;&#96;,&#96;&#96;&#96;.mp4&#96;&#96;&#96;,&#96;&#96;&#96;.mp3&#96;&#96;&#96;,.&#96;&#96;&#96;avi</span><br></pre></td></tr></table></figure>
,（主要用处：根据文件格式，系统会自动判断用什么软件打开,<br>注意: 随意修改文件格式，对文件的本身不会造成太大的影响，比如把<code>avi</code>改成<code>mp4</code>,文件还是<code>avi.</code>）</li>
</ul>
<ul>
<li><p>视频封装格式：一种储存视频信息的容器，流式封装可以有<code>TS</code>、<code>FLV</code>等，索引式的封装有<code>MP4</code>,<code>MOV</code>,<code>AVI</code>等，（主要作用：一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、封装起来.               </p>
<pre><code>注意：会发现封装格式跟文件格式一样，因为一般视频文件格式的后缀名即采用相应的视频封装格式的名称,所以视频文件格式就是视频封装格式。）</code></pre></li>
<li><p>视频封装格式和视频压缩编码标准：就好像项目工程和编程语言，封装格式就是一个项目的工程，视频编码方式就是编程语言，一个项目工程可以用不同语言开发。</p>
</li>
</ul>
<p><strong><strong><em>视频编码框架</em></strong></strong></p>
<ul>
<li><code>FFmpeg</code>:是一个跨平台的开源视频框架,能实现如视频编码,解码,转码,串流,播放等丰富的功能。其支持的视频格式以及播放协议非常丰富,几乎包含了所有音视频编解码、封装格式以及播放协议。<ul>
<li>-Libswresample:可以对音频进行重采样,rematrixing 以及转换采样格式等操 作。</li>
<li>-Libavcodec:提供了一个通用的编解码框架,包含了许多视频,音频,字幕流 等编码/解码器。</li>
<li>-Libavformat:用于对视频进行封装/解封装。</li>
<li>-Libavutil:包含一些共用的函数,如随机数生成,数据结构,数学运算等。</li>
<li>-Libpostproc:用于进行视频的一些后期处理。</li>
<li>-Libswscale:用于视频图像缩放,颜色空间转换等。</li>
<li>-Libavfilter:提供滤镜功能。</li>
</ul>
</li>
<li><code>X264</code>:把视频原数据YUV编码压缩成H.264格式</li>
<li><code>VideoToolbox</code>:苹果自带的视频硬解码和硬编码API，但是在iOS8之后才开放。</li>
<li><code>AudioToolbox</code>:苹果自带的音频硬解码和硬编码API</li>
</ul>
<p><strong><strong><em>视频编码技术</em></strong></strong></p>
<ul>
<li><p>视频压缩编码标准：对视频进行压缩(视频编码)或者解压缩（视频解码）的编码技术,比如<code>MPEG</code>，<code>H.264</code>,这些视频编码技术是压缩编码视频的</p>
<ul>
<li>主要作用:是将视频像素数据压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。</li>
<li>注意:最影响视频质量的是其视频编码数据和音频编码数据，跟封装格式没有多大关系</li>
</ul>
</li>
<li><p><code>MPEG</code>:一种视频压缩方式，它采用了帧间压缩，仅存储连续帧之间有差别的地方 ，从而达到较大的压缩比</p>
</li>
<li><p><code>H.264/AVC</code>:一种视频压缩方式,采用事先预测和与<code>MPEG</code>中的P-B帧一样的帧预测方法压缩，它可以根据需要产生适合网络情况传输的视频流,还有更高的压缩比，有更好的图象质量</p>
<ul>
<li>注意1:如果是从单个画面清晰度比较，<code>MPEG4</code>有优势；从动作连贯性上的清晰度，<code>H.264</code>有优势</li>
<li>注意2:由于264的算法更加复杂，程序实现烦琐，运行它需要更多的处理器和内存资源。因此，运行<code>264</code>对系统要求是比较高的。</li>
<li>注意3:由于264的实现更加灵活，它把一些实现留给了厂商自己去实现，虽然这样给实现带来了很多好处，但是不同产品之间互通成了很大的问题，造成了通过A公司的编码器编出的数据，必须通过A公司的解码器去解这样尴尬的事情</li>
</ul>
</li>
<li><p><code>H.265/HEVC</code>:一种视频压缩方式,基于<code>H.264</code>，保留原来的某些技术，同时对一些相关的技术加以改进，以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。</p>
<ul>
<li><code>H.265</code> 是一种更为高效的编码标准，能够在同等画质效果下将内容的体积压缩得更小，传输时更快更省带宽</li>
</ul>
</li>
<li><p><code>I-frames帧</code>:(关键帧)保留一副完整的画面，解码时只需要本帧数据就可以完成（这些帧都是一些单独的帧或关键帧，包含创建完整图片 需要的所有数据。每个GOP都正好有一个I-frames。由于它是独立帧，其尺寸最大，但也是解压最快的）</p>
</li>
<li><p><code>P-frames帧</code>:(差别帧，预测帧)保留这一帧跟之前帧的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（P帧没有完整画面数据，只有与前一帧的画面差别的数据）</p>
</li>
<li><p><code>B-frames帧</code>:(双向差别帧)保留的是本帧与前后帧的差别，解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累</p>
</li>
<li><p><code>帧内（Intraframe）压缩</code>:当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息,帧内一般采用有损压缩算法（帧内压缩通过消除包含在每个独立视频帧内的色彩及结构中的冗余信息来进行压缩，因此可在不降低图片质量的情况下尽可能缩小尺寸，这类压缩同JEPG压缩原理类似。但通常用于对原始图片的一部分进行处理以生成极高质量的照片。通过这一过程创建的帧称为I-frames）</p>
</li>
<li><p><code>帧间（Interframe）压缩</code>:时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的(在帧内压缩中，很多帧被组合在一起作为一组图片（简称GOP），对于GOP所存在的时间维度的冗余可以被消除。如果想象视频文件中的经典场景，就会有一些特定运动元素的概念，比如行驶的汽车或街上走路的行人，场景的背景环境通常是固定的，固定的背景环境就代表一个时间维度上的冗余，这个冗余就可以通过压缩方式消除)</p>
</li>
</ul>
<p>*<code>muxing（合成）</code>：将视频流、音频流甚至是字幕流封装到一个文件中(容器格式（<code>FLV</code>，<code>TS</code>）)，作为一个信号进行传输。</p>
<h4 id="以上就是视频开发中了解的基本知识点，下面几篇文章我会每个文章都会深入的去描述项目中经常用到的类"><a href="#以上就是视频开发中了解的基本知识点，下面几篇文章我会每个文章都会深入的去描述项目中经常用到的类" class="headerlink" title="以上就是视频开发中了解的基本知识点，下面几篇文章我会每个文章都会深入的去描述项目中经常用到的类"></a>以上就是视频开发中了解的基本知识点，下面几篇文章我会每个文章都会深入的去描述项目中经常用到的类</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/26/AVFoundation%E5%85%A5%E9%97%A8/" data-id="ckamqc2zd00056z76g2efd74s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AVFoundation 文本转语音和音频录制 播放" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/26/AVFoundation%20%E6%96%87%E6%9C%AC%E8%BD%AC%E8%AF%AD%E9%9F%B3%E5%92%8C%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%20%E6%92%AD%E6%94%BE/" class="article-date">
  <time datetime="2020-05-25T16:30:11.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/26/AVFoundation%20%E6%96%87%E6%9C%AC%E8%BD%AC%E8%AF%AD%E9%9F%B3%E5%92%8C%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%20%E6%92%AD%E6%94%BE/">AVFoundation 文本转语音和音频录制 播放</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在你应该对<code>AVFoundation</code>有了比较深入的了解，并且对数字媒体的细节也有了一定认识，下面介绍一下 <code>AVFoundation</code>的文本转语音功能</p>
<h1 id="AVSpeechSynthesizer"><a href="#AVSpeechSynthesizer" class="headerlink" title="AVSpeechSynthesizer"></a><strong>AVSpeechSynthesizer</strong></h1><p>开发者可以使用<code>AVFoundation</code>中的<code>AVSpeechSynthesizer</code>类向iOS应用程序中添加类似功能，这个类用来播放一个或多个语音内容，这些语音内容都是名为<code>AVSpeechUtterance</code>的类的实例。具体的实现代码如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> synthesizer = <span class="type">AVSpeechSynthesizer</span>()</span><br><span class="line">synthesizer.speak(<span class="type">AVSpeechUtterance</span>(string: <span class="string">"Hello AV Foundation. How are you?"</span>))</span><br></pre></td></tr></table></figure>
<p>就两行代码解决了文本转语音功能。当然很多人会有自己的需求，那么还需要对具体对话中用到的声音和语音字符串定义属性。</p>
<h6 id="AVSpeechUtterance"><a href="#AVSpeechUtterance" class="headerlink" title="AVSpeechUtterance"></a>AVSpeechUtterance</h6><p>如果我们想定义声音的语速和语种那么我们就需要用<code>AVSpeechUtterance</code>类来设置一下自定义的属性</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> synthesizer = <span class="type">AVSpeechSynthesizer</span>()</span><br><span class="line"><span class="comment">//如果播放语音内容 需要用到 AVSpeechUtterance 类</span></span><br><span class="line"><span class="keyword">let</span> utterance = <span class="type">AVSpeechUtterance</span>(string: <span class="string">"Hello AV Foundation. How are you?"</span>)</span><br><span class="line"><span class="comment">//定义播放的语音语种</span></span><br><span class="line">utterance.voice = <span class="type">AVSpeechSynthesisVoice</span>(language: <span class="string">"en-US"</span>)</span><br><span class="line"><span class="comment">//定义播放语音内容的速率</span></span><br><span class="line">utterance.rate = <span class="number">0.5</span></span><br><span class="line"><span class="comment">//可在播放特定语句时改变声音的音调 pitchMultiplier 的允许值一般介于0.5（低音调）和2.0（高音调）之间</span></span><br><span class="line">utterance.pitchMultiplier = <span class="number">1.0</span></span><br><span class="line"><span class="comment">//让语音合成器在播放下一语句之前有短暂时间暂停</span></span><br><span class="line">utterance.postUtteranceDelay = <span class="number">0.5</span></span><br><span class="line"><span class="comment">//播放</span></span><br><span class="line">synthesizer.speak(utterance)</span><br></pre></td></tr></table></figure>

<p>强调一下<code>AVSpeechUtterance</code>中的<code>voice</code>属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Arabic (ar-SA)</span><br><span class="line">Chinese (zh-CN, zh-HK, zh-TW)</span><br><span class="line">Czech (cs-CZ)</span><br><span class="line">Danish (da-DK)</span><br><span class="line">Dutch (nl-BE, nl-NL)</span><br><span class="line">English (en-AU, en-GB, en-IE, en-US, en-ZA)</span><br><span class="line">Finnish (fi-FI)</span><br><span class="line">French (fr-CA, fr-FR)</span><br><span class="line">German (de-DE)</span><br><span class="line">Greek (el-GR)</span><br><span class="line">Hebrew (he-IL)</span><br><span class="line">Hindi (hi-IN)</span><br><span class="line">Hungarian (hu-HU)</span><br><span class="line">Indonesian (id-ID)</span><br><span class="line">Italian (it-IT)</span><br><span class="line">Japanese (ja-JP)</span><br><span class="line">Korean (ko-KR)</span><br><span class="line">Norwegian (no-NO)</span><br><span class="line">Polish (pl-PL)</span><br><span class="line">Portuguese (pt-BR, pt-PT)</span><br><span class="line">Romanian (ro-RO)</span><br><span class="line">Russian (ru-RU)</span><br><span class="line">Slovak (sk-SK)</span><br><span class="line">Spanish (es-ES, es-MX)</span><br><span class="line">Swedish (sv-SE)</span><br><span class="line">Thai (th-TH)</span><br><span class="line">Turkish (tr-TR)</span><br></pre></td></tr></table></figure>
<p><code>AVSpeechSynthesizer</code> 常用的<code>delegate</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//开始朗读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">speechSynthesizer</span><span class="params">(<span class="number">_</span> synthesizer: AVSpeechSynthesizer, didStart utterance: AVSpeechUtterance)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束朗读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">speechSynthesizer</span><span class="params">(<span class="number">_</span> synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暂停朗读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">speechSynthesizer</span><span class="params">(<span class="number">_</span> synthesizer: AVSpeechSynthesizer, didPause utterance: AVSpeechUtterance)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//继续朗读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">speechSynthesizer</span><span class="params">(<span class="number">_</span> synthesizer: AVSpeechSynthesizer, didContinue utterance: AVSpeechUtterance)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将要播放的语音文字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">speechSynthesizer</span><span class="params">(<span class="number">_</span> synthesizer: AVSpeechSynthesizer, willSpeakRangeOfSpeechString characterRange: NSRange, utterance: AVSpeechUtterance)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>常用的文本转语音功能介绍完了 接下来介绍下常用的音频录制和播放功能</p>
<p><strong>所有iOS应用程序都具有音频会话，无论其是否使用。默认音频会话来自于以下一些预配置：</strong></p>
<ul>
<li>激活了音频播放，但是音频录音未激活</li>
<li>当用户切换响铃/静音开光到“静音”模式时，应用程序播放的所有音频都会消失</li>
<li>当设备显示解锁屏幕时，应用程序的音频处于静音状态</li>
<li>当应用程序播放音频时，所有后台播放的音频都会处于静音状态</li>
</ul>
<p><code>AVFoundation</code>定义了7种分类来描述应用程序所使用的音频行为。</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="center">作用</th>
<th align="center">是否允许混音</th>
<th align="center">音频输入</th>
<th align="center">音频输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ambient</td>
<td align="center">游戏 效率应用程序</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="left">Solo Ambient (默认)</td>
<td align="center">游戏 效率应用程序</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="left">Playback</td>
<td align="center">音频和视频播放器</td>
<td align="center">可选</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="left">Record</td>
<td align="center">录音机  音频捕捉</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="left">Play and Record</td>
<td align="center">VoIP 语音聊天</td>
<td align="center">可选</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="left">Audio Processing</td>
<td align="center">离线会话和处理</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="left">Multi-Route</td>
<td align="center">使用外部硬件的高级A/V应用程序</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<p>上述分类所提供的几种常见行为可以满足大部分应用程序的需要，不过如果开发者需要更复杂的功能，其中一些分类可以通过使用<code>options和modes</code>方法进一步自定义开发。</p>
<p><strong>音频会话在应用程序的生命周期中是可以修改的，但通常我们只对其配置一次，就是在应用程序启动时。</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> session = <span class="type">AVAudioSession</span>.sharedInstance()</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/*AVAudioSession.Category:</span></span><br><span class="line"><span class="comment">         .ambient         混合播放，会把后台播放的音乐混合起来播放</span></span><br><span class="line"><span class="comment">         .soloAmbient     进入后台，先会把之前的后台音乐停止，在播放自己的</span></span><br><span class="line"><span class="comment">         .playback        进入后台的时候播放音乐 不会随着静音键和屏幕关闭而静音</span></span><br><span class="line"><span class="comment">         .record          用于需要录音的应用,除了来电铃声，闹钟或日历提醒之外的其它系统声音都不会被播放</span></span><br><span class="line"><span class="comment">         .playAndRecord   用于既需要播放声音又需要录音的应用 该Category提供录音和播放功能。如果你的应用需要用到iPhone上的听筒，该category是你唯一的选择，在该Category下声音的默认出口为听筒（在没有外接设备的情况下）</span></span><br><span class="line"><span class="comment">         .audioProcessing 主要用于音频格式处理，一般可以配合AudioUnit进行使用</span></span><br><span class="line"><span class="comment">         .multiRoute      这个类别可以支持多个设备输入输出。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         上面介绍的这个七大类别，可以认为是设定了七种主场景，而这七类肯定是不能满足开发者所有的需求的。CoreAudio提供的方法是，首先定下七种的一种基调，然后在进行微调。CoreAudio为每种Category都提供了些许选项来进行微调。在设置完类别后，可以通过 AVAudioSession.CategoryOptions属性 查看当前类别设置了哪些选项</span></span><br><span class="line"><span class="comment">         AVAudioSession.CategoryOptions:</span></span><br><span class="line"><span class="comment">         .mixWithOthers     是否可以和其他后台APP进行混音</span></span><br><span class="line"><span class="comment">         .duckOthers        是否压低其他APP声音</span></span><br><span class="line"><span class="comment">         .allowBluetooth    是否支持蓝牙耳机</span></span><br><span class="line"><span class="comment">         .defaultToSpeaker  是否默认用免提声音</span></span><br><span class="line"><span class="comment">         除此之外，在iOS9还提供了.interruptSpokenAudioAndMixWithOthers iOS10又新加了两个.allowBluetoothA2DP 和 .allowAirPlay用来支持蓝牙A2DP耳机和AirPlay</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         通过上面的七大类别，我们基本覆盖了常用的主场景，在每个主场景中可以通过Option进行微调。为此CoreAudio提供了七大比较常见微调后的子场景。叫做各个类别的模式。</span></span><br><span class="line"><span class="comment">         AVAudioSession.Mode:</span></span><br><span class="line"><span class="comment">         .default        每种类别默认的就是这个模式，所有要想还原的话，就设置成这个模式。</span></span><br><span class="line"><span class="comment">         .voiceChat      主要用于VoIP场景，此时系统会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集。此时有个副作用，他会设置类别的选项为".allowBluetooth"从而支持蓝牙耳机。  适用于 .playAndRecord</span></span><br><span class="line"><span class="comment">         .gameChat       适用于游戏App的采集和播放，比如“GKVoiceChat”对象，一般不需要手动设置 适用于 .playAndRecord</span></span><br><span class="line"><span class="comment">         .videoRecording 录制视频时  适用于 .playAndRecord .record</span></span><br><span class="line"><span class="comment">         .measurement    最小系统    适用于 .playAndRecord .record .playback</span></span><br><span class="line"><span class="comment">         .moviePlayback  视频播放    适用于 .playback</span></span><br><span class="line"><span class="comment">         .videoChat      主要用于视频通话，比如QQ视频、FaceTime。时系统也会选择最佳的输入设备，比如插上耳机就使用耳机上的麦克风进行采集并且会设置类别的选项为".allowBluetooth" 和 ".defaultToSpeaker"。 适用于 .playAndRecord</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">try</span> session.setCategory(.playback, mode: .<span class="keyword">default</span>, options: .mixWithOthers)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> session.setActive(<span class="literal">true</span>, options: .notifyOthersOnDeactivation)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">Error</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用AVAudionPlayer-播放音频"><a href="#使用AVAudionPlayer-播放音频" class="headerlink" title="使用AVAudionPlayer 播放音频"></a><strong>使用AVAudionPlayer 播放音频</strong></h1><p><code>AVAudioPlayer</code>构建于<code>Core Audio</code>中的<code>C-based Audio Qucue Serics</code>的最顶层。所以它可以提供所有你在 <code>Audio Oucue Services</code>中所能找到的核心功能， 比如播放、循环甚至音频计量。除非你需要从网络流中播放音频、需要访问原始音频样本或者需要非常低的时延，否则<code>AVAudioPlayer</code>都能胜任。</p>
<h4 id="创建-AVAudionPlayer"><a href="#创建-AVAudionPlayer" class="headerlink" title="创建 AVAudionPlayer"></a>创建 AVAudionPlayer</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> fileurl = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"rock"</span>, withExtension: <span class="string">"mp3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> player = <span class="keyword">try</span> <span class="type">AVAudioPlayer</span>.<span class="keyword">init</span>(contentsOf: fileurl!)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> player != <span class="literal">nil</span> &#123;</span><br><span class="line">    player.prepareToPlay()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果返回一个有效的播放实例，建议开发者调用  <code>prepareToPlay</code> 方法。这样做会取得需要的音频硬件并预加载<code>Audio Queue</code> 的缓冲区。调用 <code>prepareToPlay</code>这个动作是可选的，当调用<code>Play</code>方法时会隐形激活，不过在创建时准备播放器可以降低调用<code>Play</code>方法和听到声音之间的延时</p>
<p><code>AVAudioPlayer</code>常用属性</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置声音的大小 范围为（0到1）</span></span><br><span class="line">player?.volume = <span class="number">0.5</span></span><br><span class="line"><span class="comment">//设置循环次数，如果为负数，就是无限循环</span></span><br><span class="line">player?.numberOfLoops = -<span class="number">1</span></span><br><span class="line"><span class="comment">//设置播放进度</span></span><br><span class="line">player?.currentTime = <span class="number">0</span></span><br><span class="line"><span class="comment">//调整播放率 范围 0.5 - 2.0</span></span><br><span class="line">player?.rate = <span class="number">0.5</span></span><br><span class="line"><span class="comment">//允许使用立体声播放声音 范围从 -1.0（极左）到 1.0（极右） 默认值为0.0（居中）</span></span><br><span class="line">player?.pan = <span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<p><code>pause</code>和<code>stop</code>方法的区别：<br><code>pause</code>和<code>stop</code>方法在应用程序外面看来实现的功能都是停止当前播放行为，这两者最主要的区别在底层处理上。掉用<code>stop</code>方法会撤销掉用<code>prepareToPlay</code>时所做的设置，而调用<code>pause</code>方法则不会。</p>
<h1 id="使用AVAudionRecorder-播放音频"><a href="#使用AVAudionRecorder-播放音频" class="headerlink" title="使用AVAudionRecorder 播放音频"></a><strong>使用AVAudionRecorder 播放音频</strong></h1><p><code>AVAudionRecorder</code>同其于播放音频的兄弟类一样，构建于<code>Audio Qucue Serics</code>之上，是一个功能强大且代码简单易用的类。我们可以在<code>Mac</code>机器和<code>iOS</code>设备上使用这个类来从内置的麦克风录制视频，也可从外部音频设备进行录制，比如数字音频接口或USB麦克风</p>
<h4 id="创建-AVAudionRecorder"><a href="#创建-AVAudionRecorder" class="headerlink" title="创建 AVAudionRecorder"></a>创建 AVAudionRecorder</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">let</span> tmpDir = <span class="type">NSTemporaryDirectory</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fileURL = <span class="type">URL</span>.<span class="keyword">init</span>(string: tmpDir)!.appendingPathComponent(<span class="string">"memo.caf"</span>)</span><br><span class="line">        </span><br><span class="line">                      <span class="comment">/*AVEncoderAudioQualityKey：声音质量 需要的参数是一个枚举 ：</span></span><br><span class="line"><span class="comment">                        AVAudioQualityMin    最小的质量</span></span><br><span class="line"><span class="comment">                        AVAudioQualityLow    比较低的质量</span></span><br><span class="line"><span class="comment">                        AVAudioQualityMedium 中间的质量</span></span><br><span class="line"><span class="comment">                        AVAudioQualityHigh   高的质量</span></span><br><span class="line"><span class="comment">                        AVAudioQualityMax    最好的质量</span></span><br><span class="line"><span class="comment">                        AVLinearPCMBitDepthKey：比特率  8 16 32</span></span><br><span class="line"><span class="comment">                    */</span> </span><br><span class="line">        <span class="keyword">let</span> settings = [<span class="type">AVFormatIDKey</span> : [kAudioFormatAppleIMA4],</span><br><span class="line">                        <span class="type">AVSampleRateKey</span> : <span class="string">"44100.0"</span>,</span><br><span class="line">                        <span class="type">AVNumberOfChannelsKey</span> : <span class="string">"1"</span>,</span><br><span class="line">                        <span class="type">AVEncoderBitDepthHintKey</span> : <span class="string">"16"</span>,</span><br><span class="line">                        <span class="type">AVEncoderAudioQualityKey</span> : [kRenderQuality_Medium]</span><br><span class="line">                        ] <span class="keyword">as</span> [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> recorder = <span class="type">AVAudioRecorder</span>.<span class="keyword">init</span>(url: fileURL, settings: settings)</span><br><span class="line">            </span><br><span class="line">            recorder?.delegate = <span class="keyword">self</span></span><br><span class="line">            recorder?.isMeteringEnabled = <span class="literal">true</span></span><br><span class="line">            recorder?.prepareToRecord()</span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="number">_</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">``` </span><br><span class="line">成功创建`<span class="type">AVAudioRecorder</span>` 实例，建议调用期` prepareToRecord` 方法，与`<span class="type">AVPlayer</span>`的`prepareToPlay`方法类似。这个方法执行底层<span class="type">Audio</span> <span class="type">Queue</span>初始化的必要过程。该方法还在<span class="type">URL</span>参数指定的位置一个文件，将录制启动时的延迟降到最小。</span><br><span class="line"></span><br><span class="line">**在设置字典中指定的键值信息也值得讨论一番，开发者可以使用的完整可用键信息在`&lt;<span class="type">ACFoundation</span>/<span class="type">AVAudioSettings</span>.h&gt;`中定义。大部分的键都专门定义了特有的各式，不过下面介绍的都是一些通用的音频格式**</span><br><span class="line"></span><br><span class="line">**<span class="number">1</span>.音频格式**</span><br><span class="line">`<span class="type">AVFormatIDKey</span>` 键定义了写入内容的音频格式，下面的常量都是音频格式所支持的值：</span><br><span class="line"></span><br><span class="line">    kAudioFormatLinearPCM               = 'lpcm',</span><br><span class="line">    kAudioFormatAC3                     = 'ac-<span class="number">3</span>',</span><br><span class="line">    kAudioFormat60958AC3                = 'cac3',</span><br><span class="line">    kAudioFormatAppleIMA4               = 'ima4',</span><br><span class="line">    kAudioFormatMPEG4AAC                = 'aac ',</span><br><span class="line">    kAudioFormatMPEG4CELP               = 'celp',</span><br><span class="line">    kAudioFormatMPEG4HVXC               = 'hvxc',</span><br><span class="line">    kAudioFormatMPEG4TwinVQ             = 'twvq',</span><br><span class="line">    kAudioFormatMACE3                   = '<span class="type">MAC3'</span>,</span><br><span class="line">    kAudioFormatMACE6                   = '<span class="type">MAC6'</span>,</span><br><span class="line">    kAudioFormatULaw                    = 'ulaw',</span><br><span class="line">    kAudioFormatALaw                    = 'alaw',</span><br><span class="line">    kAudioFormatQDesign                 = '<span class="type">QDMC'</span>,</span><br><span class="line">    kAudioFormatQDesign2                = '<span class="type">QDM2'</span>,</span><br><span class="line">    kAudioFormatQUALCOMM                = '<span class="type">Qclp'</span>,</span><br><span class="line">    kAudioFormatMPEGLayer1              = '.mp1',</span><br><span class="line">    kAudioFormatMPEGLayer2              = '.mp2',</span><br><span class="line">    kAudioFormatMPEGLayer3              = '.mp3',</span><br><span class="line">    kAudioFormatTimeCode                = 'time',</span><br><span class="line">    kAudioFormatMIDIStream              = 'midi',</span><br><span class="line">    kAudioFormatParameterValueStream    = 'apvs',</span><br><span class="line">    kAudioFormatAppleLossless           = 'alac',</span><br><span class="line">    kAudioFormatMPEG4AAC_HE             = 'aach',</span><br><span class="line">    kAudioFormatMPEG4AAC_LD             = 'aacl',</span><br><span class="line">    kAudioFormatMPEG4AAC_ELD            = 'aace',</span><br><span class="line">    kAudioFormatMPEG4AAC_ELD_SBR        = 'aacf',</span><br><span class="line">    kAudioFormatMPEG4AAC_ELD_V2         = 'aacg',    </span><br><span class="line">    kAudioFormatMPEG4AAC_HE_V2          = 'aacp',</span><br><span class="line">    kAudioFormatMPEG4AAC_Spatial        = 'aacs',</span><br><span class="line">    kAudioFormatAMR                     = 'samr',</span><br><span class="line">    kAudioFormatAMR_WB                  = 'sawb',</span><br><span class="line">    kAudioFormatAudible                 = '<span class="type">AUDB'</span>,</span><br><span class="line">    kAudioFormatiLBC                    = 'ilbc',</span><br><span class="line">    kAudioFormatDVIIntelIMA             = <span class="number">0x6D730011</span>,</span><br><span class="line">    kAudioFormatMicrosoftGSM            = <span class="number">0x6D730031</span>,</span><br><span class="line">    kAudioFormatAES3                    = 'aes3',</span><br><span class="line">    kAudioFormatEnhancedAC3             = 'ec-<span class="number">3</span>',</span><br><span class="line">    kAudioFormatFLAC                    = 'flac',</span><br><span class="line">    kAudioFormatOpus                    = 'opus'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">指定`kAudioFormatLinearPCM`会将未压缩的音频流写入到文件中。这种格式的保真度最高，不过相应的文件也最大。选择诸如`<span class="type">AAC</span>`或`<span class="type">Apple</span> <span class="type">IMA4</span>`的压缩格式会显著缩小文件，还能保证高质量的音频内容</span><br><span class="line"></span><br><span class="line">**<span class="number">2</span>.采样率**</span><br><span class="line">`<span class="type">AVSampleRateKey</span>`用于定义录音器的采样率，采样率定义了对输入的模拟音频信号每一秒内的采样数。在录制音频的质量及最终文件大小方面，采样率扮演着至关重要的角色。使用低采样率，比如`8kHz`， 会导致粗粒度、 <span class="type">AM</span>广播类型的录制效果，不过文件会比较小，使用`<span class="number">44</span>.1kHz`的采样率(<span class="type">CD</span>质量的采样率)会得到非常高质量的内容，不过文件就比较大。对于使用什么采样率最好 没有一个明确的定义，不过开发者应该尽量使用标准的采样率，比如`<span class="number">8000</span>`、`<span class="number">16000</span>`、`<span class="number">22</span> <span class="number">050</span>`或`<span class="number">44</span> <span class="number">100</span>`。最终是我们的耳朵在进行判断。</span><br><span class="line"></span><br><span class="line">**<span class="number">3</span>.通道数**</span><br><span class="line">`<span class="type">AVNumberOfChannelsKey</span>`用于定义记录音频内容的通道数。指定默认值<span class="number">1</span>意味着使用单声道录制，设置为<span class="number">2</span>意味着使用立体声录制。除非使用外部硬件进行录制，否则通常应该创建单声道录音。</span><br><span class="line"></span><br><span class="line">**<span class="number">4</span>.指定格式的键**</span><br><span class="line">处理`<span class="type">Linear</span> <span class="type">PCM</span>`或压缩音频格式时，可以定义一些其他指定格式的键。 可在<span class="type">Xcode</span>帮助文档中的`<span class="type">AV</span> <span class="type">Foundation</span> <span class="type">Audio</span> <span class="type">Sttings</span> <span class="type">Constants</span>`引用中找到完整的列表。</span><br><span class="line"></span><br><span class="line">**`<span class="type">AVAudionRecorder</span>`常用的<span class="type">API</span>**</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareToRecord</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span>    准备录音， 这个在录音之前要调用一下， 底层可能会给你做一些事</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">record</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span>    录音</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">6.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">record</span><span class="params">(atTime time: TimeInterval)</span></span> -&gt; <span class="type">Bool</span>    在未来的某个时刻开始录音</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">record</span><span class="params">(forDuration duration: TimeInterval)</span></span> -&gt; <span class="type">Bool</span>  录音， 控制时长</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">6.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">record</span><span class="params">(atTime time: TimeInterval, forDuration duration: TimeInterval)</span></span> -&gt; <span class="type">Bool</span>  在未来的某段时间录多少时间的音频</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">pause</span><span class="params">()</span></span>  暂停</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">stop</span><span class="params">()</span></span>  停止</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">deleteRecording</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span>  删除录音</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">updateMeters</span><span class="params">()</span></span>   更新音量等数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">peakPower</span><span class="params">(forChannel channelNumber: Int)</span></span> -&gt; <span class="type">Float</span>  最高音量</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">averagePower</span><span class="params">(forChannel channelNumber: Int)</span></span> -&gt; <span class="type">Float</span>  平均音量</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> isRecording: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;   是否正在录音</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> url: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;  录音存放的url</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> settings: [<span class="type">String</span> : <span class="type">Any</span>] &#123; <span class="keyword">get</span> &#125; 录音格式配置字典</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> format: <span class="type">AVAudioFormat</span> &#123; <span class="keyword">get</span> &#125;  录音格式配置</span><br><span class="line"></span><br><span class="line"><span class="keyword">unowned</span>(unsafe) <span class="keyword">open</span> <span class="keyword">var</span> delegate: <span class="type">AVAudioRecorderDelegate?</span> 代理</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> currentTime: <span class="type">TimeInterval</span> &#123; <span class="keyword">get</span> &#125;  当前录音的时长</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">6.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> deviceCurrentTime: <span class="type">TimeInterval</span> &#123; <span class="keyword">get</span> &#125;  设备当前时间</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> channelAssignments: [<span class="type">AVAudioSessionChannelDescription</span>]? 每个声音通道描述数组</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**`<span class="type">AVAudioRecorderDelegate</span>`**</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">3.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">audioRecorderDidFinishRecording</span><span class="params">(<span class="number">_</span> recorder: AVAudioRecorder, successfully flag: Bool)</span></span>  录音成功的回调</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">3.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">audioRecorderEncodeErrorDidOccur</span><span class="params">(<span class="number">_</span> recorder: AVAudioRecorder, error: Error?)</span></span> 录音发生错误的的回调</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS, introduced: <span class="number">2.2</span>, deprecated: <span class="number">8.0</span>)</span><br><span class="line"><span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">audioRecorderBeginInterruption</span><span class="params">(<span class="number">_</span> recorder: AVAudioRecorder)</span></span>    录音开始中断的回调</span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS, introduced: <span class="number">6.0</span>, deprecated: <span class="number">8.0</span>)</span><br><span class="line"><span class="keyword">optional</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">audioRecorderEndInterruption</span><span class="params">(<span class="number">_</span> recorder: AVAudioRecorder, withOptions flags: Int)</span></span> 录音结束中断的回调</span><br></pre></td></tr></table></figure>

<h1 id="使用Audio-Metering"><a href="#使用Audio-Metering" class="headerlink" title="使用Audio Metering"></a>使用Audio Metering</h1><p><strong><code>AVAudioRecorder</code>和<code>AVAudioPlayer</code>中最强大和最实用的功能就是对音频进行测量。<code>Audio Metering</code>可让开发者读取音频的平均分贝和峰值分贝数据，并使用这些数据以可视化方式将声音的大小呈现给最终用户。</strong></p>
<p>这两个类使用的方法都是<strong><code>averagePowerForChannel</code></strong>和<strong><code>peakPowerForChannel</code></strong>。两个方法都会返回一个用于表示声音分贝（dB）等级的浮点值。这个值的范围从表示最大分贝的0Db(fullscale)到表示最小分贝或静音的-160dB。</p>
<p>在可以读取这些值之前，首先要通过设置录音器的<strong><code>isMeteringEnabled = true</code></strong>才可以支持对音频进行测量。这就使得录音器可以对捕捉到的音频样本进行分贝计算。每当需要读取值时，首页需要调用<strong><code>updateMeters()</code></strong>方法才能获取最新的值。</p>
<p>创建一个新的CADisplayLink 定时器 来实时刷新 获取分贝 定时器方法内部实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">recorder?.updateMeters()</span><br><span class="line"><span class="keyword">var</span> level = <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//获取分贝</span></span><br><span class="line"> <span class="keyword">let</span> peakPower = recorder?.peakPower(forChannel: <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//设置一个最低分贝</span></span><br><span class="line"> <span class="keyword">let</span> minDecibels:<span class="type">Float</span> = -<span class="number">60</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> peakPower &lt; minDecibels &#123;</span><br><span class="line">     level = <span class="number">0.0</span></span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span> peakPower &gt;= <span class="number">0.0</span> &#123;</span><br><span class="line">     level = <span class="number">1.0</span></span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> root            = <span class="number">2.0</span>;</span><br><span class="line">     <span class="comment">//最小分贝的波形幅度值 公式: db 分贝 A 波形幅度值   dB=20∗log(A)→A=pow(10,(db/20.0))</span></span><br><span class="line">     <span class="keyword">let</span> minAmp          = powf(<span class="number">10.0</span>, <span class="number">0.05</span> * minDecibels);</span><br><span class="line">     <span class="keyword">let</span> inverseAmpRange = <span class="number">1.0</span> / (<span class="number">1.0</span> - minAmp);</span><br><span class="line">     <span class="comment">//实时获取到波形幅度值 公式同上</span></span><br><span class="line">     <span class="keyword">let</span> amp             = powf(<span class="number">10.0</span>, <span class="number">0.05</span> * peakPower);</span><br><span class="line">     <span class="comment">//(实时数据 - 最小数据)/(最大数据 - 最小数据)  应该计算的一个比例值吧</span></span><br><span class="line">     <span class="keyword">let</span> adjAmp          = (amp - minAmp) * inverseAmpRange;</span><br><span class="line">     level = powf(adjAmp, <span class="number">1.0</span> / root);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>本章我们见识了<code>AVFoundation</code>的音频类所能提供的强大功能。<code>AVAudionSession</code>作为应用程序和更在的iOS音频环境的中间环节，可通过使用分类在语义上定义应用程序的行为，并且提供工具来观察中断和线路变化。<code>AVAudionPlayer</code>和<code>AVAudioRecorder</code>提供了一种简单但功能强大的接口，用于处理音频的播放和录制。这两个类都构建与<code>Core Audio</code>框架之上，但为在应用程序中实现音频录制和播放提供了一种更便捷的方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/26/AVFoundation%20%E6%96%87%E6%9C%AC%E8%BD%AC%E8%AF%AD%E9%9F%B3%E5%92%8C%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%20%E6%92%AD%E6%94%BE/" data-id="ckamqc2z200006z762c9beufq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用SceneKit框架来加载3D引擎" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/26/%E4%BD%BF%E7%94%A8SceneKit%E6%A1%86%E6%9E%B6%E6%9D%A5%E5%8A%A0%E8%BD%BD3D%E5%BC%95%E6%93%8E/" class="article-date">
  <time datetime="2020-05-25T16:16:57.000Z" itemprop="datePublished">2020-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/26/%E4%BD%BF%E7%94%A8SceneKit%E6%A1%86%E6%9E%B6%E6%9D%A5%E5%8A%A0%E8%BD%BD3D%E5%BC%95%E6%93%8E/">使用SceneKit框架来加载3D引擎</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>使用高级场景描述创建3D游戏并将3D内容添加到应用程序。轻松添加动画，物理模拟，粒子效果和基于物理的逼真的渲染。<br><a href="https://developer.apple.com/documentation/scenekit" target="_blank" rel="noopener">SceneKit</a>将高性能渲染引擎与描述性API结合在一起，用于导入，操作和渲染3D资源。与要求您精确实现显示场景的渲染算法的低级API（例如Metal和OpenGL）不同，SceneKit只需要描述场景的内容以及想要执行的动作或动画。</p>
<p>在使用SceneKit之前，应该熟悉基本的图形概念，例如坐标系和三维几何的数学。SceneKit使用右手坐标系，其中（默认情况下）视图方向沿负z轴，如下所示。<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e26c69eafb3.png" alt="03f7f401-5c21-4ac9-9c8c-e7640ec11d81.png"></p>
<h5 id="开始本小节之前，科普一下两种文件格式："><a href="#开始本小节之前，科普一下两种文件格式：" class="headerlink" title="开始本小节之前，科普一下两种文件格式："></a>开始本小节之前，科普一下两种文件格式：</h5><ul>
<li>.scn 文件，是SceneKit的 原生格式，这种格式的场景文件支持所有的SceneKit特性，诸如物理效果、约束以及粒子系统，并且，按照这种格式来导入场景文件，速度是最快的</li>
<li>.dae 文件，dae是Digital Asset Exchange 的缩写，这种格式的场景文件不支持SceneKit特性，诸如物理效果、约束以及粒子系统</li>
</ul>
<h3 id="在开发当中常用的SceneKit类"><a href="#在开发当中常用的SceneKit类" class="headerlink" title="在开发当中常用的SceneKit类"></a>在开发当中常用的SceneKit类</h3><p><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e26cd2d131d.png" alt="WeChat1dbfaae3566f808731bda7d577c1de88.png"></p>
<h2 id="SCNScene"><a href="#SCNScene" class="headerlink" title="SCNScene:"></a>SCNScene:</h2><p>要使用SceneKit显示3D内容，需要创建一个场景图，其中包含节点和属性的层次结构，这些层次结构一起代表了可视元素。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url:<span class="type">URL</span> = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"ship"</span>, withExtension: <span class="string">".dae"</span>)!</span><br><span class="line"><span class="keyword">let</span> scene:<span class="type">SCNScene</span> = <span class="keyword">try</span>! <span class="type">SCNScene</span>(url: url, options: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<h2 id="SCNView："><a href="#SCNView：" class="headerlink" title="SCNView："></a>SCNView：</h2><p>在macOS中，SCNView是的子类<a href="https://developer.apple.com/documentation/appkit/nsview" target="_blank" rel="noopener">NSView</a>。在iOS和tvOS中，SCNView是的子类<a href="https://developer.apple.com/documentation/uikit/uiview" target="_blank" rel="noopener">UIView</a>。作为这两种操作系统的视图层次结构的一部分，一个SCNView对象为应用程序的用户界面中的SceneKit内容提供了一个位置。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scnView:<span class="type">SCNView</span> = <span class="type">SCNView</span>(frame: <span class="type">CGRect</span>.zero)</span><br><span class="line">scnView.backgroundColor = <span class="type">UIColor</span>.clear</span><br><span class="line">scnView.scene = scene</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(scnView)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">##### 常用功能：</span><br><span class="line">- 设置帧率</span><br><span class="line">- 截屏</span><br><span class="line">- 开始和暂停游戏</span><br><span class="line">- 抗锯齿</span><br><span class="line">- 控制摄像机</span><br><span class="line">- 显示统计菜单</span><br><span class="line">- 执行渲染方式(<span class="type">OpenGL</span> /<span class="type">Metal</span>)</span><br><span class="line"></span><br><span class="line">## <span class="type">SCNNode</span>:</span><br><span class="line"></span><br><span class="line">场景图的结构元素，表示3D坐标空间中的位置和变换，可以在其中附加几何图形，灯光，照相机或其他可显示内容。节点在场景中都以树状结构存在。</span><br><span class="line"></span><br><span class="line">说白了，节点就是一个抽象的东东，看不见也摸不着，但是有着自己的坐标系和位置。它与场景（<span class="type">SCNView</span>）、游戏元素（比如灯光，摄像机和几何图形）的关系是：游戏元素要呈现出来，不能直接添加到场景中，而是绑定到节点（<span class="type">SCNNode</span>）上，再把节点添加到场景中，就能看到游戏元素了。</span><br><span class="line"></span><br><span class="line">类似<span class="type">UIView</span> 的 addSubView 的方法，<span class="type">SCNNode</span> 可以通过addChildNode 方法去添加子节点。</span><br><span class="line"><span class="type">Scene</span> 中有一个特殊的节点：root node, 场景中所有的节点要么是根节点的子节点，要么就是根节点的子节点的子节点 </span><br><span class="line"></span><br><span class="line">## <span class="type">SCNLight</span>：</span><br><span class="line">光源可以附加到节点上，在渲染场景中提供着色，负责整个场景的明暗，阴影</span><br><span class="line"></span><br><span class="line">灯光的分类(光源分为四种):</span><br><span class="line">- 环境光(<span class="type">SCNLightTypeAmbient</span>),这种光没有方向,位置在无穷远处,光均匀的散射在物体上</span><br><span class="line">- 点光源(<span class="type">SCNLightTypeOmni</span>):有固定位置,方向<span class="number">360</span>度,可以衰减</span><br><span class="line">- 平行方向光(<span class="type">SCNLightTypeDirectional</span>):只有照射的方向,没有位置,不会衰减</span><br><span class="line">- 聚焦光源(<span class="type">SNCLightTypeSpot</span>):光有固定位置,也有方向,也有照射区域,可以衰减</span><br><span class="line">![<span class="number">1892971</span>-bdcff22a8856ab60.png](https:<span class="comment">//github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e26c6f05a87.png)</span></span><br><span class="line"></span><br><span class="line">##### 示例：  </span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line"><span class="keyword">let</span> ambientLightNode = <span class="type">SCNNode</span>()</span><br><span class="line">ambientLightNode.light = <span class="type">SCNLight</span>()</span><br><span class="line">ambientLightNode.light?.type = .ambient</span><br><span class="line">ambientLightNode.light?.color = <span class="type">UIColor</span>.white</span><br></pre></td></tr></table></figure>

<h2 id="SCNCamera："><a href="#SCNCamera：" class="headerlink" title="SCNCamera："></a>SCNCamera：</h2><p>这个类似我们现实中的相机，它也有焦距、视角等。图形渲染到模型后，要添加相机我们才能看见。<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e26cca315d9.png" alt="1f516915-005c-4949-9bc9-38a3fe9f2a7d.png"></p>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><pre><code class="Swift"><span class="keyword">let</span> camera = <span class="type">SCNCamera</span>()
camera.automaticallyAdjustsZRange = <span class="literal">true</span>
camera.zNear = <span class="number">45</span>
camera.zFar = <span class="number">100</span>

<span class="keyword">let</span> cameranode = <span class="type">SCNNode</span>()
cameranode.camera = camera</code></pre>
<h5 id="常用属性："><a href="#常用属性：" class="headerlink" title="常用属性："></a>常用属性：</h5><ul>
<li>fieldOfView 视角，默认60°【值越小，看到的物体细节越在前面，即被放大】</li>
<li>focalLength  焦距，默认50mm【值越小，看到的物体越远】</li>
<li>zNear 相机能照到的最近距离，默认1m</li>
<li>zFar 相机能照到的最远的距离，默认100m</li>
<li>focusDistance 焦距 默认2.5 焦距越大，视角越小</li>
<li>focalBlurSampleCount 设置聚焦时，模糊物体模糊度 默认0</li>
</ul>
<h2 id="SCNGeometry："><a href="#SCNGeometry：" class="headerlink" title="SCNGeometry："></a>SCNGeometry：</h2><p>SCeneKit 游戏框架中的几何对象.将几何对象绑定到节点上,显示到view</p>
<h5 id="系统包含的："><a href="#系统包含的：" class="headerlink" title="系统包含的："></a>系统包含的：</h5><ul>
<li>正方体,</li>
<li>平面(SCNPlane),</li>
<li>金字塔,</li>
<li>球体,</li>
<li>圆柱体,</li>
<li>圆锥体,</li>
<li>管道,</li>
<li>环面,</li>
<li>地板(SCNFloor),</li>
<li>立体字,</li>
<li>自定义形状(通过贝塞尔曲线)创建SCNShape<br>然后赋值给Node 节点<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e26cca315d9.png" alt="图片 1.png"></li>
</ul>
<h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><pre><code class="Swift"><span class="comment">// 1. 球体</span>
<span class="type">SCNSphere</span> *sphere = [<span class="type">SCNSphere</span> sphereWithRadius:<span class="number">0.5</span>];
sphere.firstMaterial.diffuse.contents = @<span class="string">"earth.jpg"</span>;
<span class="type">SCNNode</span> *earthNode = [<span class="type">SCNNode</span> nodeWithGeometry:sphere];
<span class="comment">//2. 字体</span>
<span class="type">SCNText</span> *scntext = [<span class="type">SCNText</span> textWithString:@<span class="string">"xco"</span> extrusionDepth:<span class="number">0.3</span>];
scntext.font = [<span class="type">UIFont</span> systemFontOfSize:<span class="number">0.3</span>];
<span class="type">SCNNode</span> *textnode = [<span class="type">SCNNode</span> nodeWithGeometry:scntext];
textnode.position = <span class="type">SCNVector3Make</span>(-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>);</code></pre>
<h4 id="讲一下在SceneKit中的骨骼动画"><a href="#讲一下在SceneKit中的骨骼动画" class="headerlink" title="讲一下在SceneKit中的骨骼动画"></a>讲一下在SceneKit中的骨骼动画</h4><p>苹果官方给的定义</p>
<blockquote>
<p>骨骼动画是一种简化复杂几何形状的动画的技术,比如游戏中人的特征,动画骨架是一个简单的控制节点的层次结构,本身没有可见的几何对象,将骨头和几何对象进行结合,当你移动这个骨头控制的节点时允许SceneKit 去自动使几何对象变形。</p>
</blockquote>
<p><strong><em>如图：</em></strong><br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e26c8ed534e.jpeg" alt="1594482-3123f3954171796e.png.jpg"><br>怎么使用骨骼动画</p>
<ol>
<li>一般情况下,游戏设计师使用3D工具创建一个皮肤模型,包含了骨骼的动画,保存在一个场景文件中,你从场景文件中导入这个骨骼模型,然后让他们运动起来</li>
<li>另外你也可以直接从场景文件中导入动画对象直接操作骨头节点</li>
<li>你还可以单独创建一个自定义的几何和骨架数据的皮肤模型</li>
</ol>
<p>分析一下在Xcode中加入带有骨骼动画的3D模型的结构<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e26fee43cde.jpeg" alt="1594482-5ef45a7d2edecf3c.png.jpg"><br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e270306081d.jpeg" alt="1594482-e2133816b7a0c830.png.jpg"><br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e27184683f9.jpeg" alt="1594482-b65196d4d64c5fa7.png.jpg"></p>
<h5 id="完整的骨骼动画效果"><a href="#完整的骨骼动画效果" class="headerlink" title="完整的骨骼动画效果"></a>完整的骨骼动画效果</h5><p><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3e2706e26d8f.gif" alt="1594482-71551d5854d32b5b.gif"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/26/%E4%BD%BF%E7%94%A8SceneKit%E6%A1%86%E6%9E%B6%E6%9D%A5%E5%8A%A0%E8%BD%BD3D%E5%BC%95%E6%93%8E/" data-id="ckampd5s40000tl76elzscysj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS降低APP崩溃率" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/24/iOS%E9%99%8D%E4%BD%8EAPP%E5%B4%A9%E6%BA%83%E7%8E%87/" class="article-date">
  <time datetime="2020-05-24T14:53:08.000Z" itemprop="datePublished">2020-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/24/iOS%E9%99%8D%E4%BD%8EAPP%E5%B4%A9%E6%BA%83%E7%8E%87/">iOS降低APP崩溃率</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作为一个资深的技术团队，app的性能是我们技术团队首要的任务，其中最主要的一项就是app的崩溃率。<br>目前虽然不能把系统所有的crash都处理掉，不过一些常见的高频次发生的crash，系统都会处理。目前主要可以处理掉的crash类型有一下几种：</p>
<ul>
<li>unrecognized selector crash</li>
<li>KVO crash</li>
<li>NSNotification crash</li>
<li>NSTimer crash</li>
<li>Container crash（数组越界，插nil等）</li>
<li>NSString crash （字符串操作的crash）</li>
<li>UI not on Main Thread Crash (非主线程刷UI(机制待改善))<h5 id="下面会一一讲解如何解决这些carsh"><a href="#下面会一一讲解如何解决这些carsh" class="headerlink" title="下面会一一讲解如何解决这些carsh"></a>下面会一一讲解如何解决这些carsh</h5></li>
</ul>
<h2 id="unrecognized-selector-crash"><a href="#unrecognized-selector-crash" class="headerlink" title="unrecognized selector crash"></a>unrecognized selector crash</h2><p>unrecognized selector类型的crash是经常发生的carsh，我们要解决这个carsh就必须先了解它产生的具体原因和流程。</p>
<p>什么时候会报unrecognized selector的异常？</p>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX</p>
<p>在找不到方法时，查找方法将会进入方法Forward流程,系统给了三次补救的机会，所以我们要解决这个问题，在这三次均可以解决这个问题<br><img src="/MExuanHe.github.io/fancybox/images/rootsearch.png" alt="图片"><br>由上图可见，在一个函数找不到时，runtime提供了三种方式去补救：</p>
<p>1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数<br>2、调用forwardingTargetForSelector让别的对象去执行这个函数<br>3、调用forwardInvocation（函数执行器)灵活的将目标函数以其他形式执行。</p>
<p>如果都不中，调用doesNotRecognizeSelector抛出异常。既然可以补救,我们可以用消息转发机制来做，我们选择了第二步forwardingTargetForSelector来做，原因如下：</p>
<p>1、resolveInstanceMethod 需要在类的本身上动态添加它本身不存在的方法，这些方法对于该类本身来说冗余的</p>
<p>2、forwardInvocation可以通过NSInvocation的形式将消息转发给多个对象，但是其开销较大，需要创建新的NSInvocation对象，并且forwardInvocation的函数经常被使用者调用，来做多层消息转发选择机制，不适合多次重写</p>
<p>3、forwardingTargetForSelector可以将消息转发给一个对象，开销较小，并且被重写的概率较低，适合重写<br>选择了forwardingTargetForSelector之后，可以将NSObject的该方法重写</p>
<p>做以下几步的处理：</p>
<p>1、动态创建一个桩类</p>
<p>2、动态为桩类添加对应的Selector，用一个通用的返回0的函数来实现该SEL的IMP</p>
<p>3、将消息直接转发到这个桩类对象上。<br>流程图如下：<br><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3ef056e30b35.png" alt="图片2"><br>注意如果对象的类本事如果重写了forwardInvocation方法的话，就不应该对forwardingTargetForSelector进行重写了，否则会影响到该类型的对象原本的消息转发流程。</p>
<p>通过重写NSObject的forwardingTargetForSelector方法，我们就可以将无法识别的方法进行拦截并且将消息转发到安全的桩类对象中，从而可以使app继续正常运行。</p>
<h2 id="KVO-crash"><a href="#KVO-crash" class="headerlink" title="KVO crash"></a>KVO crash</h2><p>如果观察者和keypath的数量一多，很容易理不清楚被观察对象整个KVO关系，导致被观察者在dealloc的时候，还残存着一些关系没有被注销。 同时还会导致KVO注册观察者与移除观察者不匹配的情况发生。<br>那么如何来管理混乱的KVO关系呢。可以让被观察对象持有一个KVO的delegate，所有和KVO相关的操作均通过delegate来进行管理，delegate通过建立一张map来维护KVO整个关系<br>这样做的好处有两个：</p>
<p>1、如果出现KVO重复添加观察者或重复移除观察者（KVO注册观察者与移除观察者不匹配）的情况，delegate可以直接阻止这些非正常的操作。</p>
<p>2、被观察对象dealloc之前，可以通过delegate自动将与自己有关的KVO关系都注销掉，避免了KVO的被观察者dealloc时仍然注册着KVO导致的crash。<br>被swizzle的方法分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer </span><br><span class="line">			forKeyPath:(NSString *)keyPath</span><br><span class="line">			 	options:(NSKeyValueObservingOptions)options </span><br><span class="line">			 	context:(nullable void *)context;</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</span><br></pre></td></tr></table></figure>

<p>关于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer </span><br><span class="line">			forKeyPath:(NSString *)keyPath</span><br><span class="line">			 	options:(NSKeyValueObservingOptions)options </span><br><span class="line">			 	context:(nullable void *)context;</span><br></pre></td></tr></table></figure>
<p><strong>方法改造流程如下图：</strong><br><img src="/MExuanHe.github.io/fancybox/images/170d3ef057740bea.png" alt="图片3.png"><br>通过上面的流程，将observerd对象的所有kvo相关的observer信息全部转移到KVOdelegate上，并且避免了相同kvoinfo被重复添加多次的可能性。<br>关于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObserver:(NSObject *)observer</span><br><span class="line">            forKeyPath:(NSString *)keyPath</span><br><span class="line">               context:(void *)context</span><br></pre></td></tr></table></figure>
<p>方法改造流程如下图：<br><img src="/MExuanHe.github.io/fancybox/images/170d3ef058373d96.png" alt="图片 4.png"><br>移除一个keypath的Observer时，当delegate的kvoInfoMap中找不到key为该keypath的时候，说明此时delegate并没有持有对应keypath的observer，即说明移除了一个不匹配的观察者，此时如果再继续操作会导致app崩溃，所以应该及时中断流程，然后统计异常信息。</p>
<p>当keypath对应的KVOInfo列表（infoArray）为空的时候，说明此时delegate已经不再持有任何和keypath相关的observer了。这时应该调用原有removeObserver的方法将delegate对应的观察者移除。<br>注意到在检查遍历infoArray的时侯，除了要删除对应的info信息，还多了一步检查info.observer == nil的过程，是因为如果observer为nil，那么此时如果keypath对应的值变化的话，也会因为找不到observer而崩溃，所以需要做这一步来阻止该种情况的发生。</p>
<h6 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary&lt;NSString *,id&gt; *)change</span><br><span class="line">                       context:(void *)context</span><br></pre></td></tr></table></figure>
<p>delegate对于observeValueForKeyPath方法的修改最主要的地法规，在于将对应的响应方法转移给真正的KVO Observer，通过keyInfoMap找到keypath对应的KVOInfo里面预先存储好的observer，然后调用observer原本的响应方法</p>
<p>同时在遍历InfoArray的时候，发现info.observerw == nil的时候，需要及时将其清除掉，避免KVO的观察者observer被释放后value变化导致的crash</p>
<p>最后，针对 KVO的被观察者dealloc时仍然注册着KVO导致的crash 的情况</p>
<p>可以将NSObject的dealloc swizzle， 在object dealloc的时候自动将其对应的kvodelegate所有和kvo相关的数据清空，然后将kvodelegate也置空。避免出现KVO的被观察者dealloc时仍然注册着KVO而产生的crash</p>
<h2 id="NSNotification-crash"><a href="#NSNotification-crash" class="headerlink" title="NSNotification crash"></a>NSNotification crash</h2><p>当一个对象添加了notification之后，如果dealloc的时候，仍然持有notification，就会出现NSNotification类型的crash。</p>
<p>利用method swizzling hook NSObject的dealloc函数，再对象真正dealloc之前先调用一下[[NSNotificationCenter defaultCenter] removeObserver:self] 即可。</p>
<p>注意到并不是所有的对象都需要做以上的操作，如果一个对象从来没有被NSNotificationCenter 添加为observer的话，在其dealloc之前调用removeObserver完全是多此一举。 所以我们hook了NSNotificationCenter的addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject 函数，在其添加observer的时候，对observer动态添加标记flag。这样在observer dealloc的时候，就可以通过flag标记来判断其是否有必要调用removeObserver函数了。</p>
<h2 id="NSTimer-crash"><a href="#NSTimer-crash" class="headerlink" title="NSTimer crash"></a>NSTimer crash</h2><p>NSTimer存在以下问题:<br>•    Target是强引用，内存泄漏<br>•    在宿主不存在的时候，清理NSTimer</p>
<p>解决方法: Hook NSTimer中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats方法</span><br></pre></td></tr></table></figure>

<p>1、当repeats为NO时，走原始方法<br>2、当repeats为YES时，新建一个对象，声明一个target属性为weak类型，指向参数的target,当中间对象的target为空时，清理NSTimer</p>
<h2 id="Container-crash（数组越界，插nil等）"><a href="#Container-crash（数组越界，插nil等）" class="headerlink" title="Container crash（数组越界，插nil等）"></a>Container crash（数组越界，插nil等）</h2><p>Container 类型的crash 指的是容器类的crash</p>
<p><strong>常见的有:</strong></p>
<ul>
<li>NSArray</li>
<li>NSMutableArray</li>
<li>NSDictionary</li>
<li>NSMutableDictionary</li>
<li>NSCache</li>
</ul>
<p>一些常见的越界，插入nil，等错误操作均会导致此类crash发生</p>
<p>Container crash 类型的防护方案也比较简单,针对于NSArray／NSMutableArray／NSDictionary／NSMutableDictionary／NSCache的一些常用的会导致崩溃的API进行method swizzling，然后在swizzle的新方法中加入一些条件限制和判断，从而让这些API变的安全，这里就不展开来具体描述了。</p>
<h2 id="NSString-crash-（字符串操作的crash）"><a href="#NSString-crash-（字符串操作的crash）" class="headerlink" title="NSString crash （字符串操作的crash）"></a>NSString crash （字符串操作的crash）</h2><p>NSString／NSMutableString 类型的crash的产生原因和防护方案与Container crash很相像，这里也不展开来描述了。</p>
<h2 id="UI-not-on-Main-Thread-Crash-非主线程刷UI"><a href="#UI-not-on-Main-Thread-Crash-非主线程刷UI" class="headerlink" title="UI not on Main Thread Crash (非主线程刷UI)"></a>UI not on Main Thread Crash (非主线程刷UI)</h2><p>在非主线程刷UI将会导致app运行crash，有必要对其进行处理。 目前初步的处理方案是swizzle UIView类的以下三个方法：</p>
<ul>
<li>(void)setNeedsLayout;</li>
<li>(void)setNeedsDisplay;</li>
<li>(void)setNeedsDisplayInRect:(CGRect)rect;</li>
</ul>
<p>在这三个方法调用的时候判断一下当前的线程，如果不是主线程的话，直接利用<br>dispatch_async(dispatch_get_main_queue(), ^{<br>//调用原本方法<br>});</p>
<p>来将对应的刷UI的操作转移到主线程上，同时统计错误信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/24/iOS%E9%99%8D%E4%BD%8EAPP%E5%B4%A9%E6%BA%83%E7%8E%87/" data-id="ckamlrppl0002xj76enr1a73j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS无侵入的埋点方案如何实现？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/MExuanHe.github.io/2020/05/24/iOS%E6%97%A0%E4%BE%B5%E5%85%A5%E7%9A%84%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/" class="article-date">
  <time datetime="2020-05-24T14:49:57.000Z" itemprop="datePublished">2020-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/MExuanHe.github.io/2020/05/24/iOS%E6%97%A0%E4%BE%B5%E5%85%A5%E7%9A%84%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/">iOS无侵入的埋点方案如何实现？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在开发过程中，埋点可以解决两大类问题：一是了解用户使用 App 的行为，二是降低分析线上问题的难度。目前，iOS 开发中常见的埋点方式，主要包括：</p>
<ul>
<li>代码埋点</li>
<li>可视化埋点</li>
<li>无埋点</li>
</ul>
<h3 id="代码埋点"><a href="#代码埋点" class="headerlink" title="代码埋点"></a>代码埋点</h3><p>代码埋点主要就是通过手写代码的方式来埋点，能很精确的在需要埋点的代码处加上埋点的代码，可以很方便地记录当前环境的变量值，方便调试，并跟踪埋点内容，但存在开发工作量大，并且埋点代码到处都是，后期难以维护等问题。  </p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>显而易见，你会在后期维护的时候写的怀疑人生</li>
<li>复用性差，几乎不能移植给其他项目</li>
<li>工作量大，而且会越写越多</li>
<li>统计代码上线之后，如果出现问题，只能后续版本迭代</li>
<li>如果统计项目名字改变了，原来老的APP版本依旧会统计老的页面名字</li>
</ol>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>如果非要写一个其他统计无法做到的优点的话，那就是可自定义程度高吧，统计代码想写到那里写到那里（其实这些也可以在后面的方案实现，只是实现上稍微麻烦一点罢了）</li>
<li>最容易想到的方案（前期费时少，使用起来费手不费思路）</li>
</ol>
<h3 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h3><p>就是将埋点增加和修改的工作可视化了，提升了增加和维护埋点的体验。</p>
<h4 id="该方案的具体步骤就是："><a href="#该方案的具体步骤就是：" class="headerlink" title="该方案的具体步骤就是："></a>该方案的具体步骤就是：</h4><ol>
<li>从后台获取需要统计的地方</li>
<li>hook住需要统计的类的load方法来Method Swizzing要统计的方法</li>
<li>上传统计到的事件给后台分析</li>
</ol>
<p>用<code>UIViewController</code>、<code>UIControl</code>为例子，讲解一下该方案的思路。</p>
<p>UIViewController PV统计,页面的统计较为简单，利用Method Swizzing hook 系统的viewDidLoad， 直接通过页面名称即可锁定页面的展示代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+(void)load &#123; </span><br><span class="line">     <span class="keyword">static</span> dispatch_once_t onceToken; </span><br><span class="line">     dispatch_once(&amp;onceToken, ^&#123; </span><br><span class="line">     <span class="type">SEL</span> originalDidLoadSelector = @selector(viewDidLoad); </span><br><span class="line">     <span class="type">SEL</span> swizzingDidLoadSelector = @selector(analytic_viewDidLoad); </span><br><span class="line">     [<span class="type">MethodSwizzingTool</span> swizzingForClass:[<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>] <span class="title">originalSel</span>:<span class="title">originalDidLoadSelector</span> <span class="title">swizzingSel</span>:<span class="title">swizzingDidLoadSelector</span>]; </span></span><br><span class="line"><span class="class">&#125;); </span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"> -(<span class="title">void</span>)<span class="title">analytic_viewDidLoad</span> </span>&#123;</span><br><span class="line">    [<span class="keyword">self</span>  analytic_viewDidLoad]; </span><br><span class="line">    <span class="comment">//用当前类的类名作为统计页面的标识符  </span></span><br><span class="line">    <span class="type">NSString</span> * identifier = [<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@"</span>, [<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>]];</span></span><br><span class="line"><span class="class">     //通过当前类名获取<span class="title">PAGEPV</span>表内的对应的页面的<span class="title">pageid</span>和<span class="title">pagename</span>  </span></span><br><span class="line"><span class="class">     <span class="title">NSDictionary</span> * <span class="title">dic</span> = [[[<span class="title">AnalyticTool</span> <span class="title">shareInstance</span>].<span class="title">data</span> <span class="title">objectForKey</span>:@"<span class="title">PAGE</span>"] <span class="title">objectForKey</span>:<span class="title">identifier</span>]; </span></span><br><span class="line"><span class="class">     <span class="title">if</span> (<span class="title">dic</span>) </span>&#123; </span><br><span class="line">     <span class="type">NSString</span> * pageid = dic[@<span class="string">"screenData"</span>][@<span class="string">"pageid"</span>]; </span><br><span class="line">     <span class="type">NSString</span> * pagename = dic[@<span class="string">"screenData"</span>][@<span class="string">"pagename"</span>]; </span><br><span class="line">     [<span class="type">AnalyticTool</span> upLoadScreenName:pagename withScreenID:pageid]; </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="type">UIControl</span> 点击统计,主要通过hook sendAction:to:forEvent: 来实现, 其唯一标识符我们用 targetname/selector/tag来标记，具体代码如下：</span><br><span class="line"></span><br><span class="line">``` <span class="type">Swift</span></span><br><span class="line">+(void)load </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">static</span> dispatch_once_t onceToken; </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123; </span><br><span class="line">    <span class="type">SEL</span> originalSelector = @selector(sendAction:to:forEvent:); </span><br><span class="line">    <span class="type">SEL</span> swizzingSelector = @selector(analytic_sendAction:to:forEvent:); </span><br><span class="line">    [<span class="type">MethodSwizzingTool</span> swizzingForClass:[<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>] <span class="title">originalSel</span>:<span class="title">originalSelector</span> <span class="title">swizzingSel</span>:<span class="title">swizzingSelector</span>]; </span></span><br><span class="line"><span class="class">    &#125;); </span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-(<span class="title">void</span>)<span class="title">analytic_sendAction</span>:(<span class="title">SEL</span>)<span class="title">action</span> <span class="title">to</span>:(<span class="title">id</span>)<span class="title">target</span> <span class="title">forEvent</span>:(<span class="title">UIEvent</span> *)<span class="title">event</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">     [<span class="keyword">self</span> analytic_sendAction:action to:target forEvent:event];</span><br><span class="line">     <span class="type">NSString</span> * identifier = [<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@/%@/%ld"</span>, [target <span class="class"><span class="keyword">class</span>], </span></span><br><span class="line"><span class="class">     <span class="title">NSStringFromSelector</span>(<span class="title">action</span>),<span class="title">self</span>.<span class="title">tag</span>]; <span class="title">NSDictionary</span> * <span class="title">dic</span> = [[[<span class="title">AnalyticTool</span> <span class="title">shareInstance</span>].<span class="title">data</span> <span class="title">objectForKey</span>:@"<span class="title">ACTION</span>"] <span class="title">objectForKey</span>:<span class="title">identifier</span>]; </span></span><br><span class="line"><span class="class">     <span class="title">if</span> (<span class="title">dic</span>) </span>&#123;</span><br><span class="line">     <span class="type">NSString</span> * eventid = dic[@<span class="string">"ActionData"</span>][@<span class="string">"eventid"</span>]; </span><br><span class="line">     <span class="type">NSString</span> * targetname = dic[@<span class="string">"ActionData"</span>][@<span class="string">"target"</span>]; </span><br><span class="line">     <span class="type">NSString</span> * pageid = dic[@<span class="string">"ActionData"</span>][@<span class="string">"pageid"</span>]; </span><br><span class="line">     <span class="type">NSString</span> * pagename = dic[@<span class="string">"ActionData"</span>][@<span class="string">"pagename"</span>];</span><br><span class="line">     [<span class="type">AnalyticTool</span> upLoadActionEventWithScreenName:pagename withScreenID:pageid withTargetName:targetname withEventID:eventid]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>需要后台配合</li>
<li>可拓展性不是很高，因为需要修改后台下发的统计内容来每次的版本统计扩展</li>
</ol>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>相对于第一种方案，代码量少了很多。</li>
<li>动态化从后台获取统计内容，方便线上修改</li>
</ol>
<h3 id="无埋点"><a href="#无埋点" class="headerlink" title="无埋点"></a>无埋点</h3><p>无埋点，并不是不需要埋点，而更确切地说是“全埋点”，而且埋点代码不会出现在业务代码中，容易管理和维护。它的缺点在于，埋点成本高，后期的解析也比较复杂，再加上 view_path 的不确定性。所以，这种方案并不能解决所有的埋点需求，但对于大量通用的埋点需求来说，能够节省大量的开发和维护成本。</p>
<p>在这其中，可视化埋点和无埋点，都属于是无侵入的埋点方案，因为它们都不需要在工程代码中写入埋点代码。所以，采用这样的无侵入埋点方案，既可以做到埋点被统一维护，又可以实现和工程代码的解耦。</p>
<p>接下来，我们就通过今天这篇文章，一起来分析一下无侵入埋点方案的实现问题吧。</p>
<h3 id="运行时方法替换方式进行埋点"><a href="#运行时方法替换方式进行埋点" class="headerlink" title="运行时方法替换方式进行埋点"></a>运行时方法替换方式进行埋点</h3><p>我们都知道，在 iOS 开发中最常见的三种埋点，就是对页面进入次数、页面停留时间、点击事件的埋点。对于这三种常见情况，我们都可以通过运行时方法替换技术来插入埋点代码，以实现无侵入的埋点方法。具体的实现方法是：先写一个运行时方法替换的类 <code>ViewHook</code>，加上替换的方法 <code>hookClass:fromSelector:toSelector</code>，代码如下：</p>
<pre><code class="Swift">
#<span class="keyword">import</span> "ViewHook.h"
#<span class="keyword">import</span> &lt;objc/runtime.h&gt;

@implementation <span class="type">ViewHook</span>

+ (void)hookClass:(<span class="type">Class</span>)classObject fromSelector:(<span class="type">SEL</span>)fromSelector toSelector:(<span class="type">SEL</span>)toSelector {
    <span class="type">Class</span> <span class="class"><span class="keyword">class</span> = <span class="title">classObject</span>;</span>
<span class="class">    // 得到被替换类的实例方法</span>
<span class="class">    <span class="title">Method</span> <span class="title">fromMethod</span> = <span class="title">class_getInstanceMethod</span>(<span class="title">class</span>, <span class="title">fromSelector</span>);</span>
<span class="class">    // 得到替换类的实例方法</span>
<span class="class">    <span class="title">Method</span> <span class="title">toMethod</span> = <span class="title">class_getInstanceMethod</span>(<span class="title">class</span>, <span class="title">toSelector</span>);</span>
<span class="class"></span>
<span class="class">    // <span class="title">class_addMethod</span> 返回成功表示被替换的方法没实现，然后会通过 <span class="title">class_addMethod</span> 方法先实现；返回失败则表示被替换方法已存在，可以直接进行 <span class="title">IMP</span> 指针交换 </span>
<span class="class">    <span class="title">if</span>(<span class="title">class_addMethod</span>(<span class="title">class</span>, <span class="title">fromSelector</span>, <span class="title">method_getImplementation</span>(<span class="title">toMethod</span>), <span class="title">method_getTypeEncoding</span>(<span class="title">toMethod</span>))) </span>{
      <span class="comment">// 进行方法的替换</span>
        class_replaceMethod(<span class="class"><span class="keyword">class</span>, <span class="title">toSelector</span>, <span class="title">method_getImplementation</span>(<span class="title">fromMethod</span>), <span class="title">method_getTypeEncoding</span>(<span class="title">fromMethod</span>));</span>
<span class="class">    } <span class="title">else</span> </span>{
      <span class="comment">// 交换 IMP 指针</span>
        method_exchangeImplementations(fromMethod, toMethod);
    }

}

@end
</code></pre>
<p>这个方法利用运行时<code>method_exchangeImplementations</code>  接口将方法的实现进行了交换，原方法调用时就会被<code>hook</code>  住，从而去执行指定的方法。</p>
<p><strong>页面进入次数、页面停留时间都需要对 UIViewController 生命周期进行埋点</strong>，你可以创建一个 UIViewController 的 Category，代码如下：</p>
<pre><code class="Swift">
@implementation <span class="type">UIViewController</span> (logger)
+ (void)load {
    <span class="keyword">static</span> dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        <span class="comment">// 通过 @selector 获得被替换和替换方法的 SEL，作为 ViewHook:hookClass:fromeSelector:toSelector 的参数传入 </span>
        <span class="type">SEL</span> fromSelectorAppear = @selector(viewWillAppear:);
        <span class="type">SEL</span> toSelectorAppear = @selector(hook_viewWillAppear:);
        [<span class="type">ViewHook</span> hookClass:<span class="keyword">self</span> fromSelector:fromSelectorAppear toSelector:toSelectorAppear];

        <span class="type">SEL</span> fromSelectorDisappear = @selector(viewWillDisappear:);
        <span class="type">SEL</span> toSelectorDisappear = @selector(hook_viewWillDisappear:);

        [<span class="type">ViewHook</span> hookClass:<span class="keyword">self</span> fromSelector:fromSelectorDisappear toSelector:toSelectorDisappear];
    });
}

- (void)hook_viewWillAppear:(<span class="type">BOOL</span>)animated {
    <span class="comment">// 先执行插入代码，再执行原 viewWillAppear 方法</span>
    [<span class="keyword">self</span> insertToViewWillAppear];
    [<span class="keyword">self</span> hook_viewWillAppear:animated];
}
- (void)hook_viewWillDisappear:(<span class="type">BOOL</span>)animated {
    <span class="comment">// 执行插入代码，再执行原 viewWillDisappear 方法</span>
    [<span class="keyword">self</span> insertToViewWillDisappear];
    [<span class="keyword">self</span> hook_viewWillDisappear:animated];
}

- (void)insertToViewWillAppear {
    <span class="comment">// 在 ViewWillAppear 时进行日志的埋点</span>
    [[[[<span class="type">SMLogger</span> create]
       message:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@ Appear"</span>,<span class="type">NSStringFromClass</span>([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>])]]</span>
<span class="class">      <span class="title">classify</span>:<span class="title">ProjectClassifyOperation</span>]</span>
<span class="class">     <span class="title">save</span>];</span>
<span class="class">}</span>
<span class="class">- (<span class="title">void</span>)<span class="title">insertToViewWillDisappear</span> </span>{
    <span class="comment">// 在 ViewWillDisappear 时进行日志的埋点</span>
    [[[[<span class="type">SMLogger</span> create]
       message:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"%@ Disappear"</span>,<span class="type">NSStringFromClass</span>([<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>])]]</span>
<span class="class">      <span class="title">classify</span>:<span class="title">ProjectClassifyOperation</span>]</span>
<span class="class">     <span class="title">save</span>];</span>
<span class="class">}</span>
<span class="class">@<span class="title">end</span></span></code></pre>
<p>可以看到，<code>Category</code>  在<code>+load()</code>  方法里使用了 ViewHook 进行方法替换，在替换的方法里执行需要埋点的方法 <code>[self insertToViewWillAppear]。</code> 这样的话，每个<code>UIViewController</code>  生命周期到了<code>ViewWillAppear</code> 时都会去执行<code>insertToViewWillAppear</code>  方法。</p>
<p>那么，我们要怎么区别不同的 <code>UIViewController</code> 呢？我一般采取的做法都是，使用<code>NSStringFromClass([self class])</code>  方法来取类名。这样，我就能够通过类名来区别不同的 <code>UIViewController</code>  了。</p>
<p><strong>对于点击事件来说，我们也可以通过运行时方法替换的方式进行无侵入埋点</strong>。这里最主要的工作是，找到这个点击事件的方法 sendAction:to:forEvent:，然后在 +load() 方法使用 ViewHook 替换成为你定义的方法。完整代码实现如下：</p>
<pre><code class="Swift">
+ (void)load {
    <span class="keyword">static</span> dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        <span class="comment">// 通过 @selector 获得被替换和替换方法的 SEL，作为 ViewHook:hookClass:fromeSelector:toSelector 的参数传入</span>
        <span class="type">SEL</span> fromSelector = @selector(sendAction:to:forEvent:);
        <span class="type">SEL</span> toSelector = @selector(hook_sendAction:to:forEvent:);
        [<span class="type">ViewHook</span> hookClass:<span class="keyword">self</span> fromSelector:fromSelector toSelector:toSelector];
    });
}

- (void)hook_sendAction:(<span class="type">SEL</span>)action to:(id)target forEvent:(<span class="type">UIEvent</span> *)event {
    [<span class="keyword">self</span> insertToSendAction:action to:target forEvent:event];
    [<span class="keyword">self</span> hook_sendAction:action to:target forEvent:event];
}
- (void)insertToSendAction:(<span class="type">SEL</span>)action to:(id)target forEvent:(<span class="type">UIEvent</span> *)event {
    <span class="comment">// 日志记录</span>
    <span class="keyword">if</span> ([[[event allTouches] anyObject] phase] == <span class="type">UITouchPhaseEnded</span>) {
        <span class="type">NSString</span> *actionString = <span class="type">NSStringFromSelector</span>(action);
        <span class="type">NSString</span> *targetName = <span class="type">NSStringFromClass</span>([target <span class="class"><span class="keyword">class</span>]);</span>
<span class="class">        [[[<span class="title">SMLogger</span> <span class="title">create</span>] <span class="title">message</span>:[<span class="title">NSString</span> <span class="title">stringWithFormat</span>:@"%@ %@",<span class="title">targetName</span>,<span class="title">actionString</span>]] <span class="title">save</span>];</span>
<span class="class">    }</span>
<span class="class">}</span></code></pre>
<p>和 UIViewController 生命周期埋点不同的是，UIButton 在一个视图类中可能有多个不同的继承类，相同 UIButton 的子类在不同视图类的埋点也要区别开。所以，我们需要通过 “action 选择器名NSStringFromSelector(action)” +“视图类名 NSStringFromClass([target class])”组合成一个唯一的标识，来进行埋点记录。</p>
<p>除了 UIViewController、UIButton 控件以外，Cocoa 框架的其他控件都可以使用这种方法来进行无侵入埋点。以 Cocoa 框架中最复杂的 UITableView 控件为例，你可以使用 hook setDelegate 方法来实现无侵入埋点。另外，对于 Cocoa 框架中的手势事件（Gesture Event），我们也可以通过 hook initWithTarget:action: 方法来实现无侵入埋点。</p>
<h2 id="事件唯一标识"><a href="#事件唯一标识" class="headerlink" title="事件唯一标识"></a>事件唯一标识</h2><p>通过运行时方法替换的方式，我们能够 hook 住所有的 Objective-C 方法，可以说是大而全了，能够帮助我们解决绝大部分的埋点问题。</p>
<p>但是，这种方案的精确度还不够高，还无法区分相同类在不同视图树节点的情况。比如，一个视图下相同 UIButton 的不同实例，仅仅通过 “action 选择器名”+“视图类名”的组合还不能够区分开。这时，我们就需要有一个唯一标识来区分不同的事件。接下来，我就跟你说说<strong>如何制定出这个唯一标识。</strong></p>
<p>这时，我首先想到的就是，能不能通过视图层级的路径来解决这个问题。因为每个页面都有一个视图树结构，通过视图的 superview 和 subviews 的属性，我们就能够还原出每个页面的视图树。视图树的顶层是 UIWindow，每个视图都在树的子节点上。如下图所示：</p>
<p><img src="https://github.com/MExuanHe/MExuanHe.github.io/raw/master/fancybox/images/170d3eba9c53c6c8.png" alt="cbfb127db8ed2545fd3ce0aa3ae6f452.png"></p>
<p>一个视图下的子节点可能是同一个视图的不同实例，比如上图中 UIView 视图节点下的两个 UIButton 是同一个类的不同实例，所以光靠视图树的路径还是没法唯一确定出视图的标识。那么，这种情况下，我们又应该如何区别不同的视图呢？</p>
<p>这时，我们想到了索引：每个子视图在父视图中都会有自己的索引，所以如果我们再加上这个索引的话，每个视图的标识就是唯一的了</p>
<p>接下来的一个问题是，视图层级路径加上在父视图中的索引来进行唯一标识，是不是就能够涵盖所有情况了呢？</p>
<p>当然不是。我们还需要考虑类似 UITableViewCell 这种具有可复用机制的视图，Cell 会在页面滚动时不断复用，所以加索引的方式还是没法用。</p>
<p>但这个问题也并不是无解的。UITableViewCell 需要使用 indexPath，这个值里包含了 section 和 row 的值。所以，我们可以通过 indexPath 来确定每个 Cell 的唯一性。</p>
<p>除了 UITableViewCell 这种情况之外， UIAlertController 也比较特殊。它的特殊性在于视图层级的不固定，因为它可能出现在任何页面中。但是，我们都知道它的功能区分往往通过弹窗内容来决定，所以可以通过内容来确定它的唯一标识。</p>
<p>除此之外，还有更多需要特殊处理的情况，但我们总是可以通过一些办法去确定它们的唯一性，所以我在这里也就不再一一列举了。思路上来说就是，想办法找出元素间不相同的因素然后进行组合，最后形成一个能够区别于其他元素的标识来。</p>
<p>除了上面提到的这些特殊情况外，还有一种情况使得我们也难以得到准确的唯一标识。如果视图层级在运行时会被更改，比如执行 insertSubView:atIndex:、removeFromSuperView 等方法时，我们也无法得到唯一标识，即使只截取部分路径也无法保证后期代码更新时不会动到这个部分。就算是运行时视图层级不会修改，以后需求迭代页面更新频繁的话，视图唯一标识也需要同步的更新维护。</p>
<p>这种问题就不好解决了，事件唯一标识的准确性难以保障，这也是通过运行时方法替换进行无侵入埋点很难在各个公司全面铺开的原因。虽然无侵入埋点无法覆盖到所有情况，全面铺开面临挑战，但是无侵入埋点还是解决了大部分的埋点需求，也节省了大量的人力成本。</p>
<p>最好的方案永远是针对于不同的场景来说的，我们不可能在一个创业团队一开始就选择方案3的架构，所以对于你来说，你要自己抉择目前而言对你最好的方案，如果你没有后台业务同学的支持，方案1也许对你来说真的是最好的方案了，起码是可以完成统计需求，虽然苦点累点。但是在合适的时间，切换不同的选择，才是成长的体现，还是最开始的话，如果你在的团队，已经给你了资源和时间去完善埋点这个模块，如果你把它做的更好，那一定是一件很酷的事情。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://neyoufan.github.io/2017/04/19/ios/%E7%BD%91%E6%98%93HubbleData%E6%97%A0%E5%9F%8B%E7%82%B9SDK%E5%9C%A8iOS%E7%AB%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">网易HubbleData无痕埋点SDK实现</a></li>
<li><a href="https://www.jianshu.com/p/69ce01e15042" target="_blank" rel="noopener">iOS无埋点数据SDK实践之路</a></li>
<li><a href="https://tech.meituan.com/2017/03/02/mt-mobile-analytics-practice.html" target="_blank" rel="noopener">美团前端无痕埋点方案</a></li>
<li><a href="https://wereadteam.github.io/2016/06/30/Aspects/" target="_blank" rel="noopener">微信读书团队Aspects的基本原理</a></li>
<li><a href="http://ayeio.com/ios/2017/03/19/%E5%85%B3%E4%BA%8E-iOS%E6%89%93%E7%82%B9%E6%9D%82%E8%B0%88.html" target="_blank" rel="noopener">iOS打点杂谈</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/MExuanHe/MExuanHe.github.io/2020/05/24/iOS%E6%97%A0%E4%BE%B5%E5%85%A5%E7%9A%84%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/" data-id="ckamlrppj0001xj769izgbew2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/MExuanHe.github.io/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/MExuanHe.github.io/2020/05/26/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96%20-%20OCLint/">OCLint</a>
          </li>
        
          <li>
            <a href="/MExuanHe.github.io/2020/05/26/%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF%EF%BC%88Target-Action%EF%BC%89/">组件之间的通讯（Target-Action）</a>
          </li>
        
          <li>
            <a href="/MExuanHe.github.io/2020/05/26/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%88%E7%A7%81%E6%9C%89%E5%BA%93%EF%BC%89/">组件化实战篇（私有库）</a>
          </li>
        
          <li>
            <a href="/MExuanHe.github.io/2020/05/26/JAVA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%EF%BC%89/">JAVA（本地服务器配置微信支付）</a>
          </li>
        
          <li>
            <a href="/MExuanHe.github.io/2020/05/26/AVFoundation%E5%85%A5%E9%97%A8/">AVFoundation入门</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/MExuanHe.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/MExuanHe.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/MExuanHe.github.io/fancybox/jquery.fancybox.css">

  
<script src="/MExuanHe.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/MExuanHe.github.io/js/script.js"></script>




  </div>
</body>
</html>